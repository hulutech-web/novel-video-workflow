package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	mcp "github.com/mark3labs/mcp-go/mcp"
	mcp_server "github.com/mark3labs/mcp-go/server"
	"go.uber.org/zap"
	aegisub "novel-video-workflow/pkg/tools/aegisub"
	"novel-video-workflow/pkg/tools/indextts2"
	tts "novel-video-workflow/pkg/tools/tts"
	"novel-video-workflow/pkg/workflow"
	"os"
	"path/filepath"
	"time"
)

// Handler processes MCP requests
type Handler struct {
	server    *mcp_server.MCPServer
	processor *workflow.Processor
	logger    *zap.Logger
	toolNames []string
}

// NewHandler creates a new handler
func NewHandler(server *mcp_server.MCPServer, processor *workflow.Processor, logger *zap.Logger) *Handler {
	h := &Handler{
		server:    server,
		processor: processor,
		logger:    logger,
		toolNames: make([]string, 0),
	}

	return h
}

// RegisterTools registers all tools with the MCP server
func (h *Handler) RegisterTools() {
	// Register process_chapter tool
	processChapterTool := mcp.NewTool("process_chapter",
		mcp.WithDescription("Process a single novel chapter"),
		mcp.WithString("chapter_text", mcp.Required(), mcp.Description("The text of the chapter to process")),
		mcp.WithNumber("chapter_number", mcp.Required(), mcp.Description("The number of the chapter")),
	)

	h.server.AddTool(processChapterTool, h.handleProcessChapter)
	h.toolNames = append(h.toolNames, "process_chapter")

	// Register generate_audio tool
	generateAudioTool := mcp.NewTool("generate_audio",
		mcp.WithDescription("Generate audio file (TTS)"),
		mcp.WithString("text", mcp.Required(), mcp.Description("The text to convert to speech")),
		mcp.WithString("reference_audio", mcp.Description("Reference audio file path for voice cloning")),
		mcp.WithString("output_file", mcp.Description("Output audio file path")),
	)

	h.server.AddTool(generateAudioTool, h.handleGenerateAudio)
	h.toolNames = append(h.toolNames, "generate_audio")

	// Register generate_indextts2_audio tool - 新增的Indextts2 TTS工具
	generateIndextts2AudioTool := mcp.NewTool("generate_indextts2_audio",
		mcp.WithDescription("Generate audio file using IndexTTS2 with advanced voice cloning capabilities"),
		mcp.WithString("text", mcp.Required(), mcp.Description("The text to convert to speech")),
		mcp.WithString("reference_audio", mcp.Required(), mcp.Description("Reference audio file path for voice cloning")),
		mcp.WithString("output_file", mcp.Description("Output audio file path")),
	)

	h.server.AddTool(generateIndextts2AudioTool, h.handleGenerateIndextts2Audio)
	h.toolNames = append(h.toolNames, "generate_indextts2_audio")

	// Register generate_subtitles_from_indextts2 tool - Aegisub字幕生成工具
	generateSubtitlesTool := mcp.NewTool("generate_subtitles_from_indextts2",
		mcp.WithDescription("Generate subtitles (SRT) from IndexTTS2 audio and provided text using Aegisub"),
		mcp.WithString("audio_file", mcp.Required(), mcp.Description("The audio file path generated by IndexTTS2")),
		mcp.WithString("text_content", mcp.Required(), mcp.Description("The text content to generate subtitles for")),
		mcp.WithString("output_file", mcp.Required(), mcp.Description("Output SRT subtitle file path")),
	)

	h.server.AddTool(generateSubtitlesTool, h.handleGenerateSubtitlesFromIndextts2)
	h.toolNames = append(h.toolNames, "generate_subtitles_from_indextts2")

	h.logger.Info("MCP tools registered",
		zap.Int("tool_count", len(h.toolNames)))
}

// handleProcessChapter handles single chapter processing
func (h *Handler) handleProcessChapter(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	chapterText, err := request.RequireString("chapter_text")
	if err != nil {
		h.logger.Error("Missing chapter_text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: chapter_text"), nil
	}

	chapterNumber, err := request.RequireFloat("chapter_number")
	if err != nil {
		h.logger.Error("Missing chapter_number parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: chapter_number"), nil
	}

	result, err := h.processor.ProcessChapter(ctx, workflow.ChapterParams{
		Text:   chapterText,
		Number: int(chapterNumber),
	})

	if err != nil {
		h.logger.Error("Failed to process chapter", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to process chapter: %v", err)), nil
	}

	resultJSON, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize result", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize result: %v", err)), nil
	}

	return mcp.NewToolResultText(string(resultJSON)), nil
}

// handleGenerateAudio generates audio
func (h *Handler) handleGenerateAudio(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	// 获取可选参数
	referenceAudio := request.GetString("reference_audio", "")
	outputFile := request.GetString("output_file", "")

	ttsTool := tts.NewTTSProcessor(h.logger)
	result, err := ttsTool.Generate(text, outputFile, referenceAudio)
	if err != nil {
		h.logger.Error("Failed to generate audio", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to generate audio: %v", err)), nil
	}

	response := map[string]interface{}{
		"success": result.Success,
		"file":    result.OutputFile,
	}

	if !result.Success {
		response["error"] = result.Error
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// handleGenerateIndextts2Audio generates audio using the new Indextts2 client
func (h *Handler) handleGenerateIndextts2Audio(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	referenceAudio, err := request.RequireString("reference_audio")
	if err != nil {
		h.logger.Error("Missing reference_audio parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: reference_audio"), nil
	}

	// 获取可选参数
	outputFile := request.GetString("output_file", "")

	// 如果outputFile为空，生成默认路径
	if outputFile == "" {
		outputFile = fmt.Sprintf("output/indextts2_output_%d.wav", time.Now().Unix())
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用新的Indextts2客户端
	client := indextts2.NewIndexTTS2Client(h.logger, "http://localhost:7860")

	// 调用Indextts2客户端生成音频
	var result indextts2.TTSResult
	err = client.GenerateTTSWithAudio(referenceAudio, text, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate audio with Indextts2", zap.Error(err))
		result = indextts2.TTSResult{
			Success: false,
			Error:   fmt.Sprintf("Failed to generate audio with Indextts2: %v", err),
		}
	} else {
		result = indextts2.TTSResult{
			Success:   true,
			AudioPath: outputFile,
		}
	}

	response := map[string]interface{}{
		"success":         result.Success,
		"file":            result.AudioPath,
		"engine":          "indextts2",
		"text":            text,
		"reference_audio": referenceAudio,
	}

	if !result.Success {
		response["error"] = result.Error
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize Indextts2 response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// handleGenerateSubtitlesFromIndextts2 generates subtitles from IndexTTS2 audio and provided text
func (h *Handler) handleGenerateSubtitlesFromIndextts2(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	audioFile, err := request.RequireString("audio_file")
	if err != nil {
		h.logger.Error("Missing audio_file parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: audio_file"), nil
	}

	textContent, err := request.RequireString("text_content")
	if err != nil {
		h.logger.Error("Missing text_content parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text_content"), nil
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: output_file"), nil
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 创建AegisubGenerator实例
	aegisubGen := aegisub.NewAegisubGenerator()

	// 使用Indextts2音频和提供的文本内容生成字幕
	err = aegisubGen.GenerateSubtitleFromIndextts2Audio(audioFile, textContent, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate subtitles from Indextts2 audio", zap.Error(err))
		response := map[string]interface{}{
			"success":     false,
			"error":       fmt.Sprintf("Failed to generate subtitles: %v", err),
			"audio_file":  audioFile,
			"output_file": outputFile,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 检查输出文件是否存在
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		h.logger.Error("Generated subtitle file does not exist", zap.String("file", outputFile))
		response := map[string]interface{}{
			"success":     false,
			"error":       "Generated subtitle file does not exist",
			"audio_file":  audioFile,
			"output_file": outputFile,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":             true,
		"audio_file":          audioFile,
		"output_file":         outputFile,
		"tool":                "aegisub_generator",
		"text_content_length": len(textContent),
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// GetToolNames gets all tool names
func (h *Handler) GetToolNames() []string {
	return h.toolNames
}

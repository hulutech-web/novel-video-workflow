package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"go.uber.org/zap"

	aegisub "novel-video-workflow/pkg/tools/aegisub"
	drawthings "novel-video-workflow/pkg/tools/drawthings"
	"novel-video-workflow/pkg/tools/file"
	"novel-video-workflow/pkg/tools/indextts2"
	"novel-video-workflow/pkg/workflow"

	mcp "github.com/mark3labs/mcp-go/mcp"
	mcp_server "github.com/mark3labs/mcp-go/server"
)

// Handler processes MCP requests
type Handler struct {
	server    *mcp_server.MCPServer
	processor *workflow.Processor
	logger    *zap.Logger
	toolNames []string
}

// NewHandler creates a new handler
func NewHandler(server *mcp_server.MCPServer, processor *workflow.Processor, logger *zap.Logger) *Handler {
	h := &Handler{
		server:    server,
		processor: processor,
		logger:    logger,
		toolNames: make([]string, 0),
	}

	return h
}

// RegisterTools registers all tools with the MCP server
func (h *Handler) RegisterTools() {

	// Register generate_indextts2_audio tool - 新增的Indextts2 TTS工具
	generateIndextts2AudioTool := mcp.NewTool("generate_indextts2_audio",
		mcp.WithDescription("Generate audio file using IndexTTS2 with advanced voice cloning capabilities"),
		mcp.WithString("text", mcp.Required(), mcp.Description("The text to convert to speech")),
		mcp.WithString("reference_audio", mcp.Required(), mcp.Description("Reference audio file path for voice cloning")),
		mcp.WithString("output_file", mcp.Description("Output audio file path")),
	)

	h.server.AddTool(generateIndextts2AudioTool, h.handleGenerateIndextts2Audio)
	h.toolNames = append(h.toolNames, "generate_indextts2_audio")

	// Register generate_subtitles_from_indextts2 tool - Aegisub字幕生成工具
	generateSubtitlesTool := mcp.NewTool("generate_subtitles_from_indextts2",
		mcp.WithDescription("Generate subtitles (SRT) from IndexTTS2 audio and provided text using Aegisub"),
		mcp.WithString("audio_file", mcp.Required(), mcp.Description("The audio file path generated by IndexTTS2")),
		mcp.WithString("text_content", mcp.Required(), mcp.Description("The text content to generate subtitles for")),
		mcp.WithString("output_file", mcp.Required(), mcp.Description("Output SRT subtitle file path")),
	)

	h.server.AddTool(generateSubtitlesTool, h.handleGenerateSubtitlesFromIndextts2)
	h.toolNames = append(h.toolNames, "generate_subtitles_from_indextts2")

	// Register file_split_novel_into_chapters tool - 用于将小说按章节拆分成独立文件夹和文件
	fileSplitNovelTool := mcp.NewTool("file_split_novel_into_chapters",
		mcp.WithDescription("Split a novel file into separate chapter folders and files based on chapter markers (e.g., '第x章')"),
		mcp.WithString("novel_path", mcp.Required(), mcp.Description("The path to the novel file to split")),
	)

	h.server.AddTool(fileSplitNovelTool, h.handleFileSplitNovelIntoChapters)
	h.toolNames = append(h.toolNames, "file_split_novel_into_chapters")

	// Register generate_image_from_text tool - DrawThings文生图工具
	generateImageFromTextTool := mcp.NewTool("generate_image_from_text",
		mcp.WithDescription("Generate image from text using DrawThings API with suspense style"),
		mcp.WithString("text", mcp.Required(), mcp.Description("The text to generate image from")),
		mcp.WithString("output_file", mcp.Required(), mcp.Description("Output image file path")),
		mcp.WithNumber("width", mcp.Description("Image width"), mcp.DefaultNumber(float64(512))),
		mcp.WithNumber("height", mcp.Description("Image height"), mcp.DefaultNumber(float64(896))),
		mcp.WithBoolean("is_suspense", mcp.Description("Apply suspense style"), mcp.DefaultBool(true)),
	)

	h.server.AddTool(generateImageFromTextTool, h.handleGenerateImageFromText)
	h.toolNames = append(h.toolNames, "generate_image_from_text")

	// Register generate_image_from_image tool - DrawThings图生图工具
	generateImageFromImageTool := mcp.NewTool("generate_image_from_image",
		mcp.WithDescription("Generate image from reference image using DrawThings API with suspense style"),
		mcp.WithString("init_image_path", mcp.Required(), mcp.Description("Reference image path for img2img")),
		mcp.WithString("text", mcp.Required(), mcp.Description("The text to guide image generation")),
		mcp.WithString("output_file", mcp.Required(), mcp.Description("Output image file path")),
		mcp.WithNumber("width", mcp.Description("Image width"), mcp.DefaultNumber(float64(512))),
		mcp.WithNumber("height", mcp.Description("Image height"), mcp.DefaultNumber(float64(896))),
		mcp.WithBoolean("is_suspense", mcp.Description("Apply suspense style"), mcp.DefaultBool(true)),
	)

	h.server.AddTool(generateImageFromImageTool, h.handleGenerateImageFromImage)
	h.toolNames = append(h.toolNames, "generate_image_from_image")

	// Register generate_images_from_chapter tool - DrawThings章节文生图工具
	generateImagesFromChapterTool := mcp.NewTool("generate_images_from_chapter",
		mcp.WithDescription("Generate images from chapter text using DrawThings API with suspense style"),
		mcp.WithString("chapter_text", mcp.Required(), mcp.Description("The chapter text to generate images from")),
		mcp.WithString("output_dir", mcp.Required(), mcp.Description("Output directory for generated images")),
		mcp.WithNumber("width", mcp.Description("Image width"), mcp.DefaultNumber(float64(512))),
		mcp.WithNumber("height", mcp.Description("Image height"), mcp.DefaultNumber(float64(896))),
		mcp.WithBoolean("is_suspense", mcp.Description("Apply suspense style"), mcp.DefaultBool(true)),
	)

	h.server.AddTool(generateImagesFromChapterTool, h.handleGenerateImagesFromChapter)
	h.toolNames = append(h.toolNames, "generate_images_from_chapter")

	// Register generate_images_from_chapter_with_ai_prompt tool - DrawThings章节文生图工具(使用AI生成提示词)
	generateImagesFromChapterWithAIPromptTool := mcp.NewTool("generate_images_from_chapter_with_ai_prompt",
		mcp.WithDescription("Generate images from chapter text using AI-generated prompts with DrawThings API and suspense style"),
		mcp.WithString("chapter_text", mcp.Required(), mcp.Description("The chapter text to generate images from")),
		mcp.WithString("output_dir", mcp.Required(), mcp.Description("Output directory for generated images")),
		mcp.WithNumber("width", mcp.Description("Image width"), mcp.DefaultNumber(float64(512))),
		mcp.WithNumber("height", mcp.Description("Image height"), mcp.DefaultNumber(float64(896))),
		mcp.WithBoolean("is_suspense", mcp.Description("Apply suspense style"), mcp.DefaultBool(true)),
	)

	h.server.AddTool(generateImagesFromChapterWithAIPromptTool, h.handleGenerateImagesFromChapterWithAIPrompt)
	h.toolNames = append(h.toolNames, "generate_images_from_chapter_with_ai_prompt")

	h.logger.Info("MCP tools registered",
		zap.Int("tool_count", len(h.toolNames)))
}

// handleGenerateAudioUpdated generates audio using IndexTTS2 directly (updated version to avoid duplicate implementation)
func (h *Handler) handleGenerateAudioUpdated(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	// 获取可选参数
	referenceAudio := request.GetString("reference_audio", "")
	outputFile := request.GetString("output_file", "")

	// 如果没有提供参考音频，尝试使用默认值
	if referenceAudio == "" {
		// 尝试查找默认参考音频
		possibilities := []string{
			"./ref.m4a",
			"./音色.m4a",
			"./assets/ref_audio/ref.m4a",
			"./assets/ref_audio/音色.m4a",
		}

		for _, path := range possibilities {
			if _, err := os.Stat(path); err == nil {
				referenceAudio = path
				h.logger.Info("Using default reference audio", zap.String("audio", referenceAudio))
				break
			}
		}

		if referenceAudio == "" {
			return mcp.NewToolResultError("No reference audio file provided and no default found"), nil
		}
	}

	// 检查参考音频是否存在
	if _, err := os.Stat(referenceAudio); os.IsNotExist(err) {
		h.logger.Error("Reference audio file does not exist", zap.String("file", referenceAudio))
		return mcp.NewToolResultError(fmt.Sprintf("Reference audio file does not exist: %s", referenceAudio)), nil
	}

	// 如果outputFile为空，生成默认路径
	if outputFile == "" {
		outputFile = fmt.Sprintf("output/audio_output_%d.wav", time.Now().Unix())
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用新的Indextts2客户端
	client := indextts2.NewIndexTTS2Client(h.logger, "http://localhost:7860")

	// 调用Indextts2客户端生成音频
	var result indextts2.TTSResult
	err = client.GenerateTTSWithAudio(referenceAudio, text, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate audio with Indextts2", zap.Error(err))
		result = indextts2.TTSResult{
			Success: false,
			Error:   fmt.Sprintf("Failed to generate audio with Indextts2: %v", err),
		}
	} else {
		result = indextts2.TTSResult{
			Success:   true,
			AudioPath: outputFile,
		}
	}

	response := map[string]interface{}{
		"success":         result.Success,
		"file":            result.AudioPath,
		"engine":          "indextts2_updated",
		"text":            text,
		"reference_audio": referenceAudio,
	}

	if !result.Success {
		response["error"] = result.Error
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// handleGenerateAudio generates audio
func (h *Handler) handleGenerateAudio(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	// 获取可选参数
	referenceAudio := request.GetString("reference_audio", "")
	outputFile := request.GetString("output_file", "")

	// 如果没有提供参考音频，尝试使用默认值
	if referenceAudio == "" {
		// 尝试查找默认参考音频
		possibilities := []string{
			"./ref.m4a",
			"./音色.m4a",
			"./assets/ref_audio/ref.m4a",
			"./assets/ref_audio/音色.m4a",
		}

		for _, path := range possibilities {
			if _, err := os.Stat(path); err == nil {
				referenceAudio = path
				h.logger.Info("Using default reference audio", zap.String("audio", referenceAudio))
				break
			}
		}

		if referenceAudio == "" {
			return mcp.NewToolResultError("No reference audio file provided and no default found"), nil
		}
	}

	// 检查参考音频是否存在
	if _, err := os.Stat(referenceAudio); os.IsNotExist(err) {
		h.logger.Error("Reference audio file does not exist", zap.String("file", referenceAudio))
		return mcp.NewToolResultError(fmt.Sprintf("Reference audio file does not exist: %s", referenceAudio)), nil
	}

	// 如果outputFile为空，生成默认路径
	if outputFile == "" {
		outputFile = fmt.Sprintf("output/audio_output_%d.wav", time.Now().Unix())
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用新的Indextts2客户端
	client := indextts2.NewIndexTTS2Client(h.logger, "http://localhost:7860")

	// 调用Indextts2客户端生成音频
	var result indextts2.TTSResult
	err = client.GenerateTTSWithAudio(referenceAudio, text, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate audio with Indextts2", zap.Error(err))
		result = indextts2.TTSResult{
			Success: false,
			Error:   fmt.Sprintf("Failed to generate audio with Indextts2: %v", err),
		}
	} else {
		result = indextts2.TTSResult{
			Success:   true,
			AudioPath: outputFile,
		}
	}

	response := map[string]interface{}{
		"success":         result.Success,
		"file":            result.AudioPath,
		"engine":          "indextts2_updated",
		"text":            text,
		"reference_audio": referenceAudio,
	}

	if !result.Success {
		response["error"] = result.Error
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// handleGenerateIndextts2Audio generates audio using the new Indextts2 client
func (h *Handler) handleGenerateIndextts2Audio(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	referenceAudio, err := request.RequireString("reference_audio")
	if err != nil {
		h.logger.Error("Missing reference_audio parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: reference_audio"), nil
	}

	// 获取可选参数
	outputFile := request.GetString("output_file", "")

	// 如果outputFile为空，生成默认路径
	if outputFile == "" {
		outputFile = fmt.Sprintf("output/indextts2_output_%d.wav", time.Now().Unix())
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用新的Indextts2客户端
	client := indextts2.NewIndexTTS2Client(h.logger, "http://localhost:7860")

	// 调用Indextts2客户端生成音频
	var result indextts2.TTSResult
	err = client.GenerateTTSWithAudio(referenceAudio, text, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate audio with Indextts2", zap.Error(err))
		result = indextts2.TTSResult{
			Success: false,
			Error:   fmt.Sprintf("Failed to generate audio with Indextts2: %v", err),
		}
	} else {
		result = indextts2.TTSResult{
			Success:   true,
			AudioPath: outputFile,
		}
	}

	response := map[string]interface{}{
		"success":         result.Success,
		"file":            result.AudioPath,
		"engine":          "indextts2",
		"text":            text,
		"reference_audio": referenceAudio,
	}

	if !result.Success {
		response["error"] = result.Error
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize Indextts2 response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleGenerateIndextts2AudioDirect 直接调用版本，用于外部工具处理器
func (h *Handler) HandleGenerateIndextts2AudioDirect(request *MockRequest) (map[string]interface{}, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: text")
	}

	referenceAudio, err := request.RequireString("reference_audio")
	if err != nil {
		h.logger.Error("Missing reference_audio parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: reference_audio")
	}

	// 获取可选参数
	outputFile := request.GetString("output_file", "")

	// 如果outputFile为空，生成默认路径
	if outputFile == "" {
		outputFile = fmt.Sprintf("output/indextts2_output_%d.wav", time.Now().Unix())
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return nil, fmt.Errorf("failed to create output directory: %v", err)
	}

	// 使用新的Indextts2客户端
	client := indextts2.NewIndexTTS2Client(h.logger, "http://localhost:7860")

	// 调用Indextts2客户端生成音频
	var result indextts2.TTSResult
	err = client.GenerateTTSWithAudio(referenceAudio, text, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate audio with Indextts2", zap.Error(err))
		result = indextts2.TTSResult{
			Success: false,
			Error:   fmt.Sprintf("Failed to generate audio with Indextts2: %v", err),
		}
	} else {
		result = indextts2.TTSResult{
			Success:   true,
			AudioPath: outputFile,
		}
	}

	response := map[string]interface{}{
		"success":         result.Success,
		"file":            result.AudioPath,
		"engine":          "indextts2",
		"text":            text,
		"reference_audio": referenceAudio,
	}

	if !result.Success {
		response["error"] = result.Error
	}

	return response, nil
}

// handleGenerateSubtitlesFromIndextts2 generates subtitles from IndexTTS2 audio and provided text
func (h *Handler) handleGenerateSubtitlesFromIndextts2(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	audioFile, err := request.RequireString("audio_file")
	if err != nil {
		h.logger.Error("Missing audio_file parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: audio_file"), nil
	}

	textContent, err := request.RequireString("text_content")
	if err != nil {
		h.logger.Error("Missing text_content parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text_content"), nil
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: output_file"), nil
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 创建AegisubGenerator实例
	aegisubGen := aegisub.NewAegisubGenerator()

	// 使用Indextts2音频和提供的文本内容生成字幕
	err = aegisubGen.GenerateSubtitleFromIndextts2Audio(audioFile, textContent, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate subtitles from Indextts2 audio", zap.Error(err))
		response := map[string]interface{}{
			"success":     false,
			"error":       fmt.Sprintf("Failed to generate subtitles: %v", err),
			"audio_file":  audioFile,
			"output_file": outputFile,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 检查输出文件是否存在
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		h.logger.Error("Generated subtitle file does not exist", zap.String("file", outputFile))
		response := map[string]interface{}{
			"success":     false,
			"error":       "Generated subtitle file does not exist",
			"audio_file":  audioFile,
			"output_file": outputFile,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":             true,
		"audio_file":          audioFile,
		"output_file":         outputFile,
		"tool":                "aegisub_generator",
		"text_content_length": len(textContent),
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleGenerateSubtitlesFromIndextts2Direct 直接调用版本
func (h *Handler) HandleGenerateSubtitlesFromIndextts2Direct(request *MockRequest) (map[string]interface{}, error) {
	audioFile, err := request.RequireString("audio_file")
	if err != nil {
		h.logger.Error("Missing audio_file parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: audio_file")
	}

	textContent, err := request.RequireString("text_content")
	if err != nil {
		h.logger.Error("Missing text_content parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: text_content")
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: output_file")
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return nil, fmt.Errorf("failed to create output directory: %v", err)
	}

	// 创建AegisubGenerator实例
	aegisubGen := aegisub.NewAegisubGenerator()

	// 使用Indextts2音频和提供的文本内容生成字幕
	err = aegisubGen.GenerateSubtitleFromIndextts2Audio(audioFile, textContent, outputFile)
	if err != nil {
		h.logger.Error("Failed to generate subtitles from Indextts2 audio", zap.Error(err))
		response := map[string]interface{}{
			"success":     false,
			"error":       fmt.Sprintf("Failed to generate subtitles: %v", err),
			"audio_file":  audioFile,
			"output_file": outputFile,
		}

		return response, nil
	}

	// 检查输出文件是否存在
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		h.logger.Error("Generated subtitle file does not exist", zap.String("file", outputFile))
		response := map[string]interface{}{
			"success":     false,
			"error":       "Generated subtitle file does not exist",
			"audio_file":  audioFile,
			"output_file": outputFile,
		}

		return response, nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":             true,
		"audio_file":          audioFile,
		"output_file":         outputFile,
		"tool":                "aegisub_generator",
		"text_content_length": len(textContent),
	}

	return response, nil
}

// handleFileSplitNovelIntoChapters splits a novel file into separate chapter folders and files
func (h *Handler) handleFileSplitNovelIntoChapters(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	novelPath, err := request.RequireString("novel_path")
	if err != nil {
		h.logger.Error("Missing novel_path parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: novel_path"), nil
	}

	// 使用FileManager工具来拆分小说
	fileManager := file.NewFileManager()
	chapters, err := fileManager.ExtractChapterTxt(novelPath)
	if err != nil {
		h.logger.Error("Failed to split novel into chapters", zap.Error(err))
		response := map[string]interface{}{
			"success":    false,
			"error":      fmt.Sprintf("Failed to split novel: %v", err),
			"novel_path": novelPath,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":       true,
		"novel_path":    novelPath,
		"chapter_count": len(chapters),
		"message":       fmt.Sprintf("Successfully split novel into %d chapters", len(chapters)),
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleFileSplitNovelIntoChaptersDirect 直接调用版本
func (h *Handler) HandleFileSplitNovelIntoChaptersDirect(request *MockRequest) (map[string]interface{}, error) {
	novelPath, err := request.RequireString("novel_path")
	if err != nil {
		h.logger.Error("Missing novel_path parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: novel_path")
	}

	// 使用FileManager工具来拆分小说
	fileManager := file.NewFileManager()
	chapters, err := fileManager.ExtractChapterTxt(novelPath)
	if err != nil {
		h.logger.Error("Failed to split novel into chapters", zap.Error(err))
		response := map[string]interface{}{
			"success":    false,
			"error":      fmt.Sprintf("Failed to split novel: %v", err),
			"novel_path": novelPath,
		}

		return response, nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":       true,
		"novel_path":    novelPath,
		"chapter_count": len(chapters),
		"message":       fmt.Sprintf("Successfully split novel into %d chapters", len(chapters)),
	}

	return response, nil
}

// handleGenerateImageFromText generates image from text using DrawThings API
func (h *Handler) handleGenerateImageFromText(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: output_file"), nil
	}

	// 获取可选参数
	width := int(request.GetInt("width", 512))
	height := int(request.GetInt("height", 896))
	isSuspense := request.GetBool("is_suspense", true)

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用DrawThings客户端生成图像
	client := drawthings.NewDrawThingsClient(h.logger, "http://localhost:7861")

	err = client.GenerateImageFromText(text, outputFile, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate image from text", zap.Error(err))
		response := map[string]interface{}{
			"success":     false,
			"error":       fmt.Sprintf("Failed to generate image: %v", err),
			"text":        text,
			"output_file": outputFile,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":     true,
		"output_file": outputFile,
		"text":        text,
		"width":       width,
		"height":      height,
		"is_suspense": isSuspense,
		"tool":        "drawthings_txt2img",
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleGenerateImageFromTextDirect 直接调用版本
func (h *Handler) HandleGenerateImageFromTextDirect(request *MockRequest) (map[string]interface{}, error) {
	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: text")
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: output_file")
	}

	// 获取可选参数
	width := request.GetInt("width", 512)
	height := request.GetInt("height", 896)
	isSuspense := request.GetBool("is_suspense", true)

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return nil, fmt.Errorf("failed to create output directory: %v", err)
	}

	// 使用DrawThings客户端生成图像
	client := drawthings.NewDrawThingsClient(h.logger, "http://localhost:7861")

	err = client.GenerateImageFromText(text, outputFile, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate image from text", zap.Error(err))
		response := map[string]interface{}{
			"success":     false,
			"error":       fmt.Sprintf("Failed to generate image: %v", err),
			"text":        text,
			"output_file": outputFile,
		}

		return response, nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":     true,
		"output_file": outputFile,
		"text":        text,
		"width":       width,
		"height":      height,
		"is_suspense": isSuspense,
		"tool":        "drawthings_txt2img",
	}

	return response, nil
}

// handleGenerateImageFromImage generates image from reference image using DrawThings API
func (h *Handler) handleGenerateImageFromImage(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	initImagePath, err := request.RequireString("init_image_path")
	if err != nil {
		h.logger.Error("Missing init_image_path parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: init_image_path"), nil
	}

	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: text"), nil
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: output_file"), nil
	}

	// 获取可选参数
	width := int(request.GetInt("width", 512))
	height := int(request.GetInt("height", 896))
	isSuspense := request.GetBool("is_suspense", true)

	// 验证参考图像文件是否存在
	if _, err := os.Stat(initImagePath); os.IsNotExist(err) {
		h.logger.Error("Reference image file does not exist", zap.String("file", initImagePath))
		response := map[string]interface{}{
			"success":         false,
			"error":           fmt.Sprintf("Reference image file does not exist: %s", initImagePath),
			"init_image_path": initImagePath,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用DrawThings客户端生成图像
	client := drawthings.NewDrawThingsClient(h.logger, "http://localhost:7861")

	err = client.GenerateImageFromImage(initImagePath, text, outputFile, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate image from reference image", zap.Error(err))
		response := map[string]interface{}{
			"success":         false,
			"error":           fmt.Sprintf("Failed to generate image: %v", err),
			"init_image_path": initImagePath,
			"text":            text,
			"output_file":     outputFile,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":         true,
		"init_image_path": initImagePath,
		"output_file":     outputFile,
		"text":            text,
		"width":           width,
		"height":          height,
		"is_suspense":     isSuspense,
		"tool":            "drawthings_img2img",
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleGenerateImageFromImageDirect 直接调用版本
func (h *Handler) HandleGenerateImageFromImageDirect(request *MockRequest) (map[string]interface{}, error) {
	initImagePath, err := request.RequireString("init_image_path")
	if err != nil {
		h.logger.Error("Missing init_image_path parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: init_image_path")
	}

	text, err := request.RequireString("text")
	if err != nil {
		h.logger.Error("Missing text parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: text")
	}

	outputFile, err := request.RequireString("output_file")
	if err != nil {
		h.logger.Error("Missing output_file parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: output_file")
	}

	// 获取可选参数
	width := request.GetInt("width", 512)
	height := request.GetInt("height", 896)
	isSuspense := request.GetBool("is_suspense", true)

	// 验证参考图像文件是否存在
	if _, err := os.Stat(initImagePath); os.IsNotExist(err) {
		h.logger.Error("Reference image file does not exist", zap.String("file", initImagePath))
		response := map[string]interface{}{
			"success":         false,
			"error":           fmt.Sprintf("Reference image file does not exist: %s", initImagePath),
			"init_image_path": initImagePath,
		}

		return response, nil
	}

	// 确保输出目录存在
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return nil, fmt.Errorf("failed to create output directory: %v", err)
	}

	// 使用DrawThings客户端生成图像
	client := drawthings.NewDrawThingsClient(h.logger, "http://localhost:7861")

	err = client.GenerateImageFromImage(initImagePath, text, outputFile, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate image from reference image", zap.Error(err))
		response := map[string]interface{}{
			"success":         false,
			"error":           fmt.Sprintf("Failed to generate image: %v", err),
			"init_image_path": initImagePath,
			"text":            text,
			"output_file":     outputFile,
		}

		return response, nil
	}

	// 成功响应
	response := map[string]interface{}{
		"success":         true,
		"init_image_path": initImagePath,
		"output_file":     outputFile,
		"text":            text,
		"width":           width,
		"height":          height,
		"is_suspense":     isSuspense,
		"tool":            "drawthings_img2img",
	}

	return response, nil
}

// GetToolNames gets all tool names
func (h *Handler) GetToolNames() []string {
	return h.toolNames
}

// handleGenerateImagesFromChapter generates images from chapter text using DrawThings API
func (h *Handler) handleGenerateImagesFromChapter(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	chapterText, err := request.RequireString("chapter_text")
	if err != nil {
		h.logger.Error("Missing chapter_text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: chapter_text"), nil
	}

	outputDir, err := request.RequireString("output_dir")
	if err != nil {
		h.logger.Error("Missing output_dir parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: output_dir"), nil
	}

	// 获取可选参数
	width := int(request.GetInt("width", 512))
	height := int(request.GetInt("height", 896))
	isSuspense := request.GetBool("is_suspense", true)

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用章节图像生成器
	generator := drawthings.NewChapterImageGenerator(h.logger)

	results, err := generator.GenerateImagesFromChapter(chapterText, outputDir, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate images from chapter", zap.Error(err))
		response := map[string]interface{}{
			"success":             false,
			"error":               fmt.Sprintf("Failed to generate images: %v", err),
			"chapter_text_length": len(chapterText),
			"output_dir":          outputDir,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	imageFiles := make([]string, len(results))
	paragraphs := make([]string, len(results))
	for i, result := range results {
		imageFiles[i] = result.ImageFile
		paragraphs[i] = result.ParagraphText
	}

	response := map[string]interface{}{
		"success":               true,
		"output_dir":            outputDir,
		"chapter_text_length":   len(chapterText),
		"generated_image_count": len(results),
		"image_files":           imageFiles,
		"paragraphs":            paragraphs,
		"width":                 width,
		"height":                height,
		"is_suspense":           isSuspense,
		"tool":                  "drawthings_chapter_txt2img",
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleGenerateImagesFromChapterDirect 直接调用版本
func (h *Handler) HandleGenerateImagesFromChapterDirect(request *MockRequest) (map[string]interface{}, error) {
	chapterText, err := request.RequireString("chapter_text")
	if err != nil {
		h.logger.Error("Missing chapter_text parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: chapter_text")
	}

	outputDir, err := request.RequireString("output_dir")
	if err != nil {
		h.logger.Error("Missing output_dir parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: output_dir")
	}

	// 获取可选参数
	width := request.GetInt("width", 512)
	height := request.GetInt("height", 896)
	isSuspense := request.GetBool("is_suspense", true)

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return nil, fmt.Errorf("failed to create output directory: %v", err)
	}

	// 使用章节图像生成器
	generator := drawthings.NewChapterImageGenerator(h.logger)

	results, err := generator.GenerateImagesFromChapter(chapterText, outputDir, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate images from chapter", zap.Error(err))
		response := map[string]interface{}{
			"success":             false,
			"error":               fmt.Sprintf("Failed to generate images: %v", err),
			"chapter_text_length": len(chapterText),
			"output_dir":          outputDir,
		}

		return response, nil
	}

	// 成功响应
	imageFiles := make([]string, len(results))
	paragraphs := make([]string, len(results))
	for i, result := range results {
		imageFiles[i] = result.ImageFile
		paragraphs[i] = result.ParagraphText
	}

	response := map[string]interface{}{
		"success":               true,
		"output_dir":            outputDir,
		"chapter_text_length":   len(chapterText),
		"generated_image_count": len(results),
		"image_files":           imageFiles,
		"paragraphs":            paragraphs,
		"width":                 width,
		"height":                height,
		"is_suspense":           isSuspense,
		"tool":                  "drawthings_chapter_txt2img",
	}

	return response, nil
}

// handleGenerateImagesFromChapterWithAIPrompt generates images from chapter text using AI-generated prompts with DrawThings API
func (h *Handler) handleGenerateImagesFromChapterWithAIPrompt(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	chapterText, err := request.RequireString("chapter_text")
	if err != nil {
		h.logger.Error("Missing chapter_text parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: chapter_text"), nil
	}

	outputDir, err := request.RequireString("output_dir")
	if err != nil {
		h.logger.Error("Missing output_dir parameter", zap.Error(err))
		return mcp.NewToolResultError("Missing required parameter: output_dir"), nil
	}

	// 获取可选参数
	width := int(request.GetInt("width", 512))
	height := int(request.GetInt("height", 896))
	isSuspense := request.GetBool("is_suspense", true)

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create output directory: %v", err)), nil
	}

	// 使用章节图像生成器（使用Ollama生成提示词）
	generator := drawthings.NewChapterImageGenerator(h.logger)

	results, err := generator.GenerateImagesFromChapter(chapterText, outputDir, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate images from chapter with AI prompts", zap.Error(err))
		response := map[string]interface{}{
			"success":             false,
			"error":               fmt.Sprintf("Failed to generate images: %v", err),
			"chapter_text_length": len(chapterText),
			"output_dir":          outputDir,
		}

		responseJSON, err := json.MarshalIndent(response, "", "  ")
		if err != nil {
			h.logger.Error("Failed to serialize error response", zap.Error(err))
			return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
		}

		return mcp.NewToolResultText(string(responseJSON)), nil
	}

	// 成功响应
	imageFiles := make([]string, len(results))
	paragraphs := make([]string, len(results))
	prompts := make([]string, len(results))

	for i, result := range results {
		imageFiles[i] = result.ImageFile
		paragraphs[i] = result.ParagraphText
		prompts[i] = result.ImagePrompt
	}

	response := map[string]interface{}{
		"success":               true,
		"output_dir":            outputDir,
		"chapter_text_length":   len(chapterText),
		"generated_image_count": len(results),
		"image_files":           imageFiles,
		"paragraphs":            paragraphs,
		"prompts":               prompts,
		"width":                 width,
		"height":                height,
		"is_suspense":           isSuspense,
		"tool":                  "drawthings_chapter_txt2img_with_ai_prompt",
	}

	responseJSON, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		h.logger.Error("Failed to serialize response", zap.Error(err))
		return mcp.NewToolResultError(fmt.Sprintf("Failed to serialize response: %v", err)), nil
	}

	return mcp.NewToolResultText(string(responseJSON)), nil
}

// HandleGenerateImagesFromChapterWithAIPromptDirect 直接调用版本
func (h *Handler) HandleGenerateImagesFromChapterWithAIPromptDirect(request *MockRequest) (map[string]interface{}, error) {
	chapterText, err := request.RequireString("chapter_text")
	if err != nil {
		h.logger.Error("Missing chapter_text parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: chapter_text")
	}

	outputDir, err := request.RequireString("output_dir")
	if err != nil {
		h.logger.Error("Missing output_dir parameter", zap.Error(err))
		return nil, fmt.Errorf("missing required parameter: output_dir")
	}

	// 获取可选参数
	width := request.GetInt("width", 512)
	height := request.GetInt("height", 896)
	isSuspense := request.GetBool("is_suspense", true)

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		h.logger.Error("Failed to create output directory", zap.Error(err))
		return nil, fmt.Errorf("failed to create output directory: %v", err)
	}

	// 使用章节图像生成器（使用Ollama生成提示词）
	generator := drawthings.NewChapterImageGenerator(h.logger)

	results, err := generator.GenerateImagesFromChapter(chapterText, outputDir, width, height, isSuspense)
	if err != nil {
		h.logger.Error("Failed to generate images from chapter with AI prompts", zap.Error(err))
		response := map[string]interface{}{
			"success":             false,
			"error":               fmt.Sprintf("Failed to generate images: %v", err),
			"chapter_text_length": len(chapterText),
			"output_dir":          outputDir,
		}

		return response, nil
	}

	// 成功响应
	imageFiles := make([]string, len(results))
	paragraphs := make([]string, len(results))
	prompts := make([]string, len(results))

	for i, result := range results {
		imageFiles[i] = result.ImageFile
		paragraphs[i] = result.ParagraphText
		prompts[i] = result.ImagePrompt
	}

	response := map[string]interface{}{
		"success":               true,
		"output_dir":            outputDir,
		"chapter_text_length":   len(chapterText),
		"generated_image_count": len(results),
		"image_files":           imageFiles,
		"paragraphs":            paragraphs,
		"prompts":               prompts,
		"width":                 width,
		"height":                height,
		"is_suspense":           isSuspense,
		"tool":                  "drawthings_chapter_txt2img_with_ai_prompt",
	}

	return response, nil
}

// MockRequest 模拟MCP请求
type MockRequest struct {
	Params map[string]interface{}
}

func (r *MockRequest) RequireString(key string) (string, error) {
	if val, exists := r.Params[key]; exists {
		if str, ok := val.(string); ok {
			return str, nil
		}
		return "", fmt.Errorf("parameter %s is not a string", key)
	}
	return "", fmt.Errorf("parameter %s not found", key)
}

func (r *MockRequest) GetString(key string, defaultValue string) string {
	if val, exists := r.Params[key]; exists {
		if str, ok := val.(string); ok {
			return str
		}
	}
	return defaultValue
}

func (r *MockRequest) GetInt(key string, defaultValue int) int {
	if val, exists := r.Params[key]; exists {
		if num, ok := val.(float64); ok {
			return int(num)
		}
		if num, ok := val.(int); ok {
			return num
		}
	}
	return defaultValue
}

func (r *MockRequest) GetBool(key string, defaultValue bool) bool {
	if val, exists := r.Params[key]; exists {
		if b, ok := val.(bool); ok {
			return b
		}
	}
	return defaultValue
}
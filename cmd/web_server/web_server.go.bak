package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	mcp_pkg "novel-video-workflow/pkg/mcp"
	"novel-video-workflow/pkg/tools/drawthings"
	workflow_pkg "novel-video-workflow/pkg/workflow"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}

// å­˜å‚¨WebSocketè¿æ¥
var clients = make(map[*websocket.Conn]bool)
var broadcast = make(chan MCPLog)

// MCPLog ç»“æ„å­˜å‚¨MCPå·¥å…·çš„æ—¥å¿—ä¿¡æ¯
type MCPLog struct {
	ToolName  string `json:"toolName"`
	Message   string `json:"message"`
	Type      string `json:"type"` // "info", "success", "error"
	Timestamp string `json:"timestamp"`
}

// ToolInfo ç»“æ„å­˜å‚¨MCPå·¥å…·çš„ä¿¡æ¯
type ToolInfo struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Path        string `json:"path"`
}

// å­˜å‚¨æ‰€æœ‰å¯ç”¨çš„MCPå·¥å…·
var mcpTools []ToolInfo
var mcpServerInstance *mcp_pkg.Server

// å¯åŠ¨MCPæœåŠ¡å™¨
func startMCPServer() error {
	// åˆ›å»ºlogger
	logger, _ := zap.NewProduction()
	defer logger.Sync()

	// åˆ›å»ºå·¥ä½œæµå¤„ç†å™¨
	processor, err := workflow_pkg.NewProcessor(logger)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºå·¥ä½œæµå¤„ç†å™¨å¤±è´¥: %v", err)
	}

	// åˆ›å»ºMCPæœåŠ¡å™¨
	server, err := mcp_pkg.NewServer(processor, logger)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºMCPæœåŠ¡å™¨å¤±è´¥: %v", err)
	}
	mcpServerInstance = server

	// è·å–å¯ç”¨å·¥å…·åˆ—è¡¨
	availableTools := server.GetHandler().GetToolNames()
	log.Printf("MCPæœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼ŒåŠ è½½äº† %d ä¸ªå·¥å…·", len(availableTools))

	// ä¸ºæ¯ä¸ªå·¥å…·åˆ›å»ºæè¿°ä¿¡æ¯
	for _, toolName := range availableTools {
		description := getToolDescription(toolName) // è·å–å·¥å…·æè¿°
		mcpTools = append(mcpTools, ToolInfo{
			Name:        toolName,
			Description: description,
			Path:        fmt.Sprintf("./mcp-tools/%s.yaml", toolName),
		})
	}

	log.Printf("Loaded %d MCP tools", len(mcpTools))

	return nil
}

func loadToolsList() {
	// å¯åŠ¨MCPæœåŠ¡å™¨
	if err := startMCPServer(); err != nil {
		log.Printf("å¯åŠ¨MCPæœåŠ¡å™¨å¤±è´¥: %v", err)
		// å³ä½¿å¯åŠ¨å¤±è´¥ï¼Œä¹Ÿè¦æä¾›é»˜è®¤å·¥å…·åˆ—è¡¨
		fallbackToolList()
		return
	}
}

// fallbackToolList æä¾›å¤‡ç”¨å·¥å…·åˆ—è¡¨
func fallbackToolList() {
	descriptions := map[string]string{
		"generate_indextts2_audio":                    "ä½¿ç”¨IndexTTS2ç”ŸæˆéŸ³é¢‘æ–‡ä»¶ï¼Œå…·æœ‰é«˜çº§è¯­éŸ³å…‹éš†åŠŸèƒ½",
		"generate_subtitles_from_indextts2":           "ä½¿ç”¨Aegisubä»IndexTTS2éŸ³é¢‘å’Œæä¾›çš„æ–‡æœ¬ç”Ÿæˆå­—å¹•(SRT)",
		"file_split_novel_into_chapters":              "æ ¹æ®ç« èŠ‚æ ‡è®°å°†å°è¯´æ–‡ä»¶æ‹†åˆ†ä¸ºå•ç‹¬çš„ç« èŠ‚æ–‡ä»¶å¤¹å’Œæ–‡ä»¶",
		"generate_image_from_text":                    "ä½¿ç”¨DrawThings APIæ ¹æ®æ–‡æœ¬ç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
		"generate_image_from_image":                   "ä½¿ç”¨DrawThings APIæ ¹æ®å‚è€ƒå›¾åƒç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
		"generate_images_from_chapter":                "ä½¿ç”¨DrawThings APIæ ¹æ®ç« èŠ‚æ–‡æœ¬ç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
		"generate_images_from_chapter_with_ai_prompt": "ä½¿ç”¨AIç”Ÿæˆæç¤ºè¯å’ŒDrawThings APIæ ¹æ®ç« èŠ‚æ–‡æœ¬ç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
	}

	defaultTools := []string{
		"generate_indextts2_audio",
		"generate_subtitles_from_indextts2",
		"file_split_novel_into_chapters",
		"generate_image_from_text",
		"generate_image_from_image",
		"generate_images_from_chapter",
		"generate_images_from_chapter_with_ai_prompt",
	}

	for _, toolName := range defaultTools {
		description, exists := descriptions[toolName]
		if !exists {
			description = fmt.Sprintf("MCPå·¥å…·: %s", toolName)
		}
		mcpTools = append(mcpTools, ToolInfo{
			Name:        toolName,
			Description: description,
			Path:        fmt.Sprintf("./mcp-tools/%s.yaml", toolName),
		})
	}

	log.Printf("åŠ è½½äº† %d ä¸ªå¤‡ç”¨å·¥å…·", len(mcpTools))
}

// getToolDescription æ ¹æ®å·¥å…·åç§°è·å–æè¿°
func getToolDescription(toolName string) string {
	descriptions := map[string]string{
		"generate_indextts2_audio":                    "ä½¿ç”¨IndexTTS2ç”ŸæˆéŸ³é¢‘æ–‡ä»¶ï¼Œå…·æœ‰é«˜çº§è¯­éŸ³å…‹éš†åŠŸèƒ½",
		"generate_subtitles_from_indextts2":           "ä½¿ç”¨Aegisubä»IndexTTS2éŸ³é¢‘å’Œæä¾›çš„æ–‡æœ¬ç”Ÿæˆå­—å¹•(SRT)",
		"file_split_novel_into_chapters":              "æ ¹æ®ç« èŠ‚æ ‡è®°å°†å°è¯´æ–‡ä»¶æ‹†åˆ†ä¸ºå•ç‹¬çš„ç« èŠ‚æ–‡ä»¶å¤¹å’Œæ–‡ä»¶",
		"generate_image_from_text":                    "ä½¿ç”¨DrawThings APIæ ¹æ®æ–‡æœ¬ç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
		"generate_image_from_image":                   "ä½¿ç”¨DrawThings APIæ ¹æ®å‚è€ƒå›¾åƒç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
		"generate_images_from_chapter":                "ä½¿ç”¨DrawThings APIæ ¹æ®ç« èŠ‚æ–‡æœ¬ç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
		"generate_images_from_chapter_with_ai_prompt": "ä½¿ç”¨AIç”Ÿæˆæç¤ºè¯å’ŒDrawThings APIæ ¹æ®ç« èŠ‚æ–‡æœ¬ç”Ÿæˆå›¾åƒï¼Œé‡‡ç”¨æ‚¬ç–‘é£æ ¼",
	}

	if desc, exists := descriptions[toolName]; exists {
		return desc
	}

	return fmt.Sprintf("MCPå·¥å…·: %s", toolName)
}

func handleLogs() {
	for {
		logData := <-broadcast
		for client := range clients {
			err := client.WriteJSON(logData)
			if err != nil {
				log.Printf("Error sending log to client: %v", err)
				delete(clients, client)
				client.Close()
			}
		}
	}
}

// Ginè·¯ç”±å¤„ç†å‡½æ•°
func homePage(c *gin.Context) {
	html := `
<!DOCTYPE html>
<html>
<head>
	<title>MCP å·¥ä½œæµæ§åˆ¶å°</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 20px;
			background-color: #f5f5f5;
		}
		.container {
			max-width: 1200px;
			margin: 0 auto;
		}
		h1 {
			color: #333;
			text-align: center;
		}
		.nav-tabs {
			display: flex;
			margin-bottom: 20px;
			background: white;
			border-radius: 5px;
			box-shadow: 0 2px 5px rgba(0,0,0,0.1);
		}
		.nav-tab {
			padding: 15px 30px;
			cursor: pointer;
			border-right: 1px solid #eee;
		}
		.nav-tab:last-child {
			border-right: none;
		}
		.nav-tab.active {
			background: #007bff;
			color: white;
		}
		.tab-content {
			display: none;
			background: white;
			padding: 20px;
			border-radius: 5px;
			box-shadow: 0 2px 5px rgba(0,0,0,0.1);
		}
		.tab-content.active {
			display: block;
		}
		.tool-card {
			border: 1px solid #ddd;
			padding: 15px;
			margin: 10px 0;
			border-radius: 5px;
			background: #f9f9f9;
		}
		.console {
			height: 400px;
			overflow-y: scroll;
			background: #000;
			color: #00ff00;
			padding: 10px;
			font-family: monospace;
			margin-top: 20px;
		}
		.console-line {
			margin: 2px 0;
		}
		.info { color: #00ff00; }
		.success { color: #00ff00; font-weight: bold; }
		.error { color: #ff5555; }
		.upload-area {
			border: 2px dashed #ccc;
			padding: 20px;
			text-align: center;
			margin: 20px 0;
			border-radius: 5px;
			cursor: pointer;
		}
		.upload-area.drag-over {
			border-color: #007bff;
			background-color: #f0f8ff;
		}
		button {
			background: #007bff;
			color: white;
			border: none;
			padding: 10px 20px;
			border-radius: 3px;
			cursor: pointer;
			margin: 5px;
		}
		button:hover {
			background: #0056b3;
		}
		input, select, textarea {
			padding: 8px;
			margin: 5px;
			border: 1px solid #ccc;
			border-radius: 3px;
			width: 100%;
			box-sizing: border-box;
		}
		.tutorial {
			line-height: 1.6;
		}
		.tutorial h3 {
			color: #007bff;
			margin-top: 20px;
		}
		.tutorial ul {
			padding-left: 20px;
		}
		.tutorial li {
			margin: 10px 0;
		}
		/* ä¸“é—¨é’ˆå¯¹éŸ³é¢‘ç”Ÿæˆå·¥å…·çš„æ ·å¼ */
		.audio-tool-form {
			background: #e7f3ff;
			padding: 15px;
			border-radius: 5px;
			margin-top: 10px;
			display: none;
		}
		.audio-tool-form.active {
			display: block;
		}
		.form-group {
			margin-bottom: 15px;
		}
		.form-group label {
			display: block;
			margin-bottom: 5px;
			font-weight: bold;
		}
		/* æ–‡ä»¶ç®¡ç†æ ·å¼ */
		.file-manager-container {
			display: flex;
			flex-direction: column;
		}
		.file-nav {
			display: flex;
			gap: 10px;
			margin-bottom: 20px;
		}
		.btn-dir {
			background: #28a745;
		}
		.btn-dir:hover {
			background: #218838;
		}
		.file-actions {
			margin-bottom: 20px;
		}
		.upload-section {
			display: inline-block;
		}
		.file-list {
			flex-grow: 1;
		}
		.file-table {
			width: 100%;
			border-collapse: collapse;
		}
		.file-table th, .file-table td {
			padding: 10px;
			text-align: left;
			border-bottom: 1px solid #ddd;
		}
		.file-table th {
			background-color: #f8f9fa;
			font-weight: bold;
		}
		.btn-preview {
			background: #ffc107;
			color: black;
		}
		.btn-preview:hover {
			background: #e0a800;
		}
		.btn-delete {
			background: #dc3545;
		}
		.btn-delete:hover {
			background: #c82333;
		}
		.file-table tr:hover {
			background-color: #f5f5f5;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>MCP å·¥ä½œæµæ§åˆ¶å°</h1>
		
		<div class="nav-tabs">
			<div class="nav-tab active" onclick="switchTab('dashboard')">ä»ªè¡¨æ¿</div>
			<div class="nav-tab" onclick="switchTab('tools')">MCP å·¥å…·</div>
			<div class="nav-tab" onclick="switchTab('upload')">ä¸Šä¼ å¹¶å¤„ç†</div>
			<div class="nav-tab" onclick="switchTab('filemanager')">æ–‡ä»¶ç®¡ç†</div>
			<div class="nav-tab" onclick="switchTab('tutorial')">æ•™ç¨‹</div>
		</div>
		
		<div id="dashboard" class="tab-content active">
			<h2>å·¥ä½œæµä»ªè¡¨æ¿</h2>
			<p>å½“å‰çŠ¶æ€: <span id="current-status">ç©ºé—²</span></p>
			<button onclick="executeAll()">æ‰§è¡Œæ‰€æœ‰ MCP å·¥å…·</button>
			<button onclick="stopExecution()">åœæ­¢æ‰§è¡Œ</button>
		</div>
		
		<div id="tools" class="tab-content">
			<h2>MCP å·¥å…·</h2>
			<div id="tools-list"></div>
		</div>
		
		<div id="upload" class="tab-content">
			<h2>ä¸Šä¼ æ–‡ä»¶å¤¹å¹¶å¤„ç†</h2>
			<div class="upload-area" id="uploadArea" ondrop="handleDrop(event)" ondragover="handleDragOver(event)">
				<p>æ‹–æ”¾æ–‡ä»¶å¤¹åˆ°æ­¤å¤„æˆ–ç‚¹å‡»é€‰æ‹©</p>
				<input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;" />
			</div>
			<button onclick="processFolder()">å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶å¤¹</button>
			<p id="uploadStatus"></p>
		</div>
		
		<div id="filemanager" class="tab-content">
			<h2>æ–‡ä»¶ç®¡ç†</h2>
			<div class="file-manager-container">
				<div class="file-nav">
					<button onclick="changeDirectory('./input')" class="btn-dir">è¾“å…¥ç›®å½• (./input)</button>
					<button onclick="changeDirectory('./output')" class="btn-dir">è¾“å‡ºç›®å½• (./output)</button>
				</div>
				<div class="file-actions">
					<div class="upload-section">
						<input type="file" id="fileUpload" onchange="handleFileUpload(this.files)" style="display: none;" />
						<button onclick="document.getElementById('fileUpload').click()">ä¸Šä¼ æ–‡ä»¶</button>
					</div>
				</div>
				<div id="fileList" class="file-list">
					<!-- æ–‡ä»¶åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€åŠ è½½ -->
				</div>
			</div>
		</div>
		
		<div id="tutorial" class="tab-content">
			<h2>æ•™ç¨‹</h2>
			<div class="tutorial">
				<h3>å…¥é—¨æŒ‡å—</h3>
				<ul>
					<li>æ­¤æ§åˆ¶å°å…è®¸æ‚¨ç®¡ç†å’Œæ‰§è¡Œ MCP æœåŠ¡</li>
					<li>ä½¿ç”¨ MCP å·¥å…·æ ‡ç­¾é¡µæŸ¥çœ‹å’Œæ‰§è¡Œå•ä¸ªå·¥å…·</li>
					<li>ä½¿ç”¨ä¸Šä¼ å¹¶å¤„ç†æ ‡ç­¾é¡µä¸Šä¼ æ–‡ä»¶å¤¹å¹¶è¿è¡Œæ•´ä¸ªå·¥ä½œæµ</li>
					<li>ä½¿ç”¨æ–‡ä»¶ç®¡ç†æ ‡ç­¾é¡µç®¡ç†inputå’Œoutputç›®å½•ä¸­çš„æ–‡ä»¶</li>
					<li>åœ¨æ¯ä¸ªéƒ¨åˆ†åº•éƒ¨çš„æ§åˆ¶å°ä¸­ç›‘è§†è¿›åº¦</li>
				</ul>
				
				<h3>æ‰§è¡Œå•ä¸ªå·¥å…·</h3>
				<ul>
					<li>å¯¼èˆªåˆ° MCP å·¥å…·æ ‡ç­¾é¡µ</li>
					<li>æ‚¨å°†çœ‹åˆ°æ‰€æœ‰å¯ç”¨ MCP å·¥å…·çš„åˆ—è¡¨</li>
					<li>ç‚¹å‡»ä»»ä½•å·¥å…·ä¸Šçš„"æ‰§è¡Œ"æŒ‰é’®å•ç‹¬è¿è¡Œå®ƒ</li>
					<li>åœ¨æ§åˆ¶å°ä¸­ç›‘è§†æ‰§è¡Œæ—¥å¿—</li>
				</ul>
				
				<h3>å¤„ç†æ•´ä¸ªæ–‡ä»¶å¤¹</h3>
				<ul>
					<li>è½¬åˆ°ä¸Šä¼ å¹¶å¤„ç†æ ‡ç­¾é¡µ</li>
					<li>æ‹–æ”¾æ–‡ä»¶å¤¹æˆ–ç‚¹å‡»é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶å¤¹</li>
					<li>ç‚¹å‡»"å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶å¤¹"å¼€å§‹å·¥ä½œæµ</li>
					<li>åœ¨æ§åˆ¶å°ä¸­ç›‘è§†è¿›åº¦</li>
				</ul>
				
				<h3>æ–‡ä»¶ç®¡ç†</h3>
				<ul>
					<li>è½¬åˆ°æ–‡ä»¶ç®¡ç†æ ‡ç­¾é¡µ</li>
					<li>ä½¿ç”¨é¡¶éƒ¨æŒ‰é’®åˆ‡æ¢åˆ°è¾“å…¥(input)æˆ–è¾“å‡º(output)ç›®å½•</li>
					<li>ç‚¹å‡»æ–‡ä»¶åå¯é¢„è§ˆæ–‡æœ¬æ–‡ä»¶å†…å®¹</li>
					<li>ç‚¹å‡»åˆ é™¤æŒ‰é’®å¯åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•</li>
					<li>ä½¿ç”¨ä¸Šä¼ æŒ‰é’®å¯ä¸Šä¼ æ–°æ–‡ä»¶</li>
				</ul>
				
				<h3>ç›‘æ§è¿›åº¦</h3>
				<ul>
					<li>æ§åˆ¶å°æ˜¾ç¤ºæ¥è‡ª MCP å·¥å…·çš„å®æ—¶æ—¥å¿—</li>
					<li>ç»¿è‰²æ–‡æœ¬è¡¨ç¤ºä¿¡æ¯æ¶ˆæ¯</li>
					<li>äº®ç»¿è‰²æ–‡æœ¬è¡¨ç¤ºæˆåŠŸæ¶ˆæ¯</li>
					<li>çº¢è‰²æ–‡æœ¬è¡¨ç¤ºé”™è¯¯æ¶ˆæ¯</li>
				</ul>
			</div>
		</div>
		
		<div class="console" id="console"></div>
	</div>

	<script>
		// WebSocketè¿æ¥
		const socket = new WebSocket('ws://' + window.location.host + '/ws');
		
		socket.onopen = function(event) {
			console.log('Connected to WebSocket');
		};
		
		socket.onmessage = function(event) {
			const logData = JSON.parse(event.data);
			const consoleDiv = document.getElementById('console');
			
			const timestamp = new Date().toLocaleTimeString();
			const lineDiv = document.createElement('div');
			lineDiv.className = 'console-line ' + logData.type;
			lineDiv.textContent = '[' + timestamp + '] [' + logData.toolName + '] ' + logData.message;
			
			consoleDiv.appendChild(lineDiv);
			consoleDiv.scrollTop = consoleDiv.scrollHeight;
		};
		
		// æ–‡ä»¶ç®¡ç†ç›¸å…³å‡½æ•°
		let currentDirectory = './input';
		
		// åˆ‡æ¢ç›®å½•
		function changeDirectory(dir) {
			currentDirectory = dir;
			loadFileList(currentDirectory);
		}
		
		// åŠ è½½æ–‡ä»¶åˆ—è¡¨
		function loadFileList(dir) {
			fetch('/api/files/list?dir=' + encodeURIComponent(dir))
				.then(response => response.json())
				.then(data => {
					const fileListDiv = document.getElementById('fileList');
					fileListDiv.innerHTML = '';
					
					if (data.files.length === 0) {
						fileListDiv.innerHTML = '<p>ç›®å½•ä¸ºç©º</p>';
						return;
					}
					
					// åˆ›å»ºæ–‡ä»¶è¡¨æ ¼
					const table = document.createElement('table');
					table.className = 'file-table';
					table.innerHTML = '<thead><tr><th>åç§°</th><th>ç±»å‹</th><th>å¤§å°</th><th>ä¿®æ”¹æ—¶é—´</th><th>æ“ä½œ</th></tr></thead><tbody></tbody>';
					
					const tbody = table.querySelector('tbody');
					
					data.files.forEach(function(file) {
						const row = document.createElement('tr');
						var fileTypeDisplay = file.isDir ? 'ğŸ“' : getFileIconByType(file.type);
						var fileSizeDisplay = file.isDir ? '-' : formatFileSize(file.size);
						var previewButton = '';
						if (!file.isDir && ['text', 'json', 'yaml', 'yml', 'xml', 'csv', 'log', 'md'].includes(file.type)) {
							previewButton = '<button onclick="previewFile(\'' + file.name + '\')" class="btn-preview">é¢„è§ˆ</button>';
						}
						var modTime = new Date(file.modTime).toLocaleString();
						row.innerHTML = '<td>' + 
							fileTypeDisplay + 
							' <span onclick="clickFileOrDir(\'' + file.name + '\', ' + file.isDir + ')" style="cursor: pointer; text-decoration: underline;">' + 
							file.name + '</span></td><td>' + 
							file.type + '</td><td>' + 
							fileSizeDisplay + '</td><td>' + 
							modTime + '</td><td>' +
							'<button onclick="deleteFile(\'' + file.name + '\', ' + file.isDir + ')" class="btn-delete">åˆ é™¤</button>' +
							previewButton + '</td>';
						tbody.appendChild(row);
					});
					
					fileListDiv.appendChild(table);
				})
				.catch(function(error) {
					console.error('Error loading file list:', error);
					const fileListDiv = document.getElementById('fileList');
					fileListDiv.innerHTML = '<p style="color: red;">åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ' + error.message + '</p>';
				});
		}
		
		// æ ¹æ®æ–‡ä»¶ç±»å‹è·å–å›¾æ ‡
		function getFileIconByType(fileType) {
			switch(fileType) {
				case 'image':
					return 'ğŸ–¼ï¸';
				case 'video':
					return 'ğŸ¬';
				case 'audio':
					return 'ğŸµ';
				case 'pdf':
					return 'ğŸ“„';
				case 'archive':
					return 'ğŸ“¦';
				case 'text':
				case 'json':
				case 'yaml':
				case 'yml':
				case 'xml':
				case 'csv':
				case 'log':
				case 'md':
					return 'ğŸ“';
				default:
					return 'ğŸ“„';
			}
		}
		
		// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
		function formatFileSize(bytes) {
			if (bytes === 0) return '0 Bytes';
			const k = 1024;
			const sizes = ['Bytes', 'KB', 'MB', 'GB'];
			const i = Math.floor(Math.log(bytes) / Math.log(k));
			return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
		}
		
		// ç‚¹å‡»æ–‡ä»¶æˆ–ç›®å½•
		function clickFileOrDir(name, isDir) {
			if (isDir) {
				// è¿›å…¥å­ç›®å½•
				var newPath = currentDirectory;
				if (newPath.endsWith('/')) {
					newPath += name;
				} else {
					newPath += '/' + name;
				}
				changeDirectory(newPath);
			} else {
				// å¯¹äºæ–‡æœ¬æ–‡ä»¶ï¼Œæ‰“å¼€é¢„è§ˆ
				previewFile(name);
			}
		}
		
		// é¢„è§ˆæ–‡ä»¶
		function previewFile(filename) {
			const fullPath = currentDirectory + '/' + filename;
			fetch('/api/files/content?path=' + encodeURIComponent(fullPath))
				.then(response => response.text())
				.then(content => {
					// åˆ›å»ºæ¨¡æ€æ¡†æ˜¾ç¤ºæ–‡ä»¶å†…å®¹
					const modal = document.createElement('div');
					modal.style.position = 'fixed';
					modal.style.top = '0';
					modal.style.left = '0';
					modal.style.width = '100%';
					modal.style.height = '100%';
					modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
					modal.style.display = 'flex';
					modal.style.justifyContent = 'center';
					modal.style.alignItems = 'center';
					modal.style.zIndex = '1000';
					
					const modalContent = document.createElement('div');
					modalContent.style.backgroundColor = 'white';
					modalContent.style.padding = '20px';
					modalContent.style.borderRadius = '5px';
					modalContent.style.width = '80%';
					modalContent.style.height = '80%';
					modalContent.style.overflow = 'auto';
					modalContent.style.position = 'relative';
					
					const closeBtn = document.createElement('button');
					closeBtn.innerHTML = '&times;';
					closeBtn.style.position = 'absolute';
					closeBtn.style.top = '10px';
					closeBtn.style.right = '15px';
					closeBtn.style.fontSize = '24px';
					closeBtn.style.cursor = 'pointer';
					closeBtn.onclick = function() { document.body.removeChild(modal); };
					
					const title = document.createElement('h3');
					title.textContent = 'é¢„è§ˆ: ' + filename;
					title.style.marginTop = '0';
					
					const contentDiv = document.createElement('pre');
					contentDiv.textContent = content;
					contentDiv.style.whiteSpace = 'pre-wrap';
					contentDiv.style.wordWrap = 'break-word';
					contentDiv.style.fontFamily = 'monospace';
					contentDiv.style.backgroundColor = '#f5f5f5';
					contentDiv.style.padding = '10px';
					contentDiv.style.borderRadius = '3px';
					contentDiv.style.overflow = 'auto';
					contentDiv.style.maxHeight = '70vh';
					
					modalContent.appendChild(closeBtn);
					modalContent.appendChild(title);
					modalContent.appendChild(contentDiv);
					modal.appendChild(modalContent);
					document.body.appendChild(modal);
				})
				.catch(function(error) {
					console.error('Error previewing file:', error);
					alert('æ— æ³•é¢„è§ˆæ–‡ä»¶: ' + error.message);
				});
		}
		
		// åˆ é™¤æ–‡ä»¶æˆ–ç›®å½•
		function deleteFile(filename, isDir) {
			var confirmMessage = 'ç¡®å®šè¦åˆ é™¤' + (isDir ? 'ç›®å½•' : 'æ–‡ä»¶') + ' "' + filename + '" å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚';
			if (confirm(confirmMessage)) {
				const fullPath = currentDirectory + '/' + filename;
				fetch('/api/files/delete?path=' + encodeURIComponent(fullPath), {
					method: 'DELETE'
				})
				.then(response => response.json())
				.then(data => {
					if (data.status === 'success') {
						alert((isDir ? 'ç›®å½•' : 'æ–‡ä»¶') + ' å·²æˆåŠŸåˆ é™¤');
						loadFileList(currentDirectory); // é‡æ–°åŠ è½½æ–‡ä»¶åˆ—è¡¨
					} else {
						alert('åˆ é™¤å¤±è´¥: ' + data.message);
					}
				})
				.catch(function(error) {
					console.error('Error deleting file:', error);
					alert('åˆ é™¤å¤±è´¥: ' + error.message);
				});
			}
		}
		
		// å¤„ç†æ–‡ä»¶ä¸Šä¼ 
		function handleFileUpload(files) {
			if (files.length === 0) return;
			
			const formData = new FormData();
			formData.append('file', files[0]);
			formData.append('dir', currentDirectory);
			
			fetch('/api/files/upload', {
				method: 'POST',
				body: formData
			})
			.then(response => response.json())
			.then(data => {
				if (data.status === 'success') {
					alert('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ' + data.filename);
					loadFileList(currentDirectory); // é‡æ–°åŠ è½½æ–‡ä»¶åˆ—è¡¨
				} else {
					alert('ä¸Šä¼ å¤±è´¥: ' + data.message);
				}
			})
			.catch(function(error) {
				console.error('Error uploading file:', error);
				alert('ä¸Šä¼ å¤±è´¥: ' + error.message);
			});
		}
		
		// å½“åˆ‡æ¢åˆ°æ–‡ä»¶ç®¡ç†æ ‡ç­¾æ—¶åŠ è½½æ–‡ä»¶åˆ—è¡¨
		function loadFileManager() {
			loadFileList(currentDirectory);
		}
		
		function switchTab(tabName) {
			// éšè—æ‰€æœ‰æ ‡ç­¾å†…å®¹
			const tabs = document.getElementsByClassName('tab-content');
			for (let i = 0; i < tabs.length; i++) {
				tabs[i].classList.remove('active');
			}
			
			// ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„æ¿€æ´»çŠ¶æ€
			const navTabs = document.getElementsByClassName('nav-tab');
			for (let i = 0; i < navTabs.length; i++) {
				navTabs[i].classList.remove('active');
			}
			
			// æ˜¾ç¤ºé€‰ä¸­çš„æ ‡ç­¾å†…å®¹
			document.getElementById(tabName).classList.add('active');
			
			// æ¿€æ´»é€‰ä¸­çš„æ ‡ç­¾
			event.target.classList.add('active');
			
			// å¦‚æœåˆ‡æ¢åˆ°å·¥å…·æ ‡ç­¾ï¼Œåˆ™åŠ è½½å·¥å…·åˆ—è¡¨
			if (tabName === 'tools') {
				loadToolsList();
			}
			// å¦‚æœåˆ‡æ¢åˆ°æ–‡ä»¶ç®¡ç†æ ‡ç­¾ï¼Œåˆ™åŠ è½½æ–‡ä»¶åˆ—è¡¨
			else if (tabName === 'filemanager') {
				loadFileManager();
			}
		}
		
		function loadToolsList() {
			fetch('/api/tools')
				.then(response => response.json())
				.then(tools => {
					const toolsListDiv = document.getElementById('tools-list');
					toolsListDiv.innerHTML = '';
					
					tools.forEach(function(tool) {
						const toolCard = document.createElement('div');
						toolCard.className = 'tool-card';
						
						// ä¸ºgenerate_indextts2_audioå·¥å…·æ·»åŠ ç‰¹æ®Šå¤„ç†
						let buttonHtml = '';
						if (tool.name === 'generate_indextts2_audio') {
							// ä¸ºéŸ³é¢‘ç”Ÿæˆå·¥å…·æ·»åŠ è¡¨å•
							buttonHtml = 
								'<h3>' + tool.name + '</h3>' +
								'<p>' + tool.description + '</p>' +
								'<button onclick="toggleAudioForm(\'' + tool.name + '\')">æ‰§è¡Œå·¥å…·</button>' +
								'<div id="form_' + tool.name + '" class="audio-tool-form">' +
									'<div class="form-group">' +
										'<label for="textInput_' + tool.name + '">è¾“å…¥æ–‡æœ¬:</label>' +
										'<textarea id="textInput_' + tool.name + '" placeholder="è¯·è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬" rows="4"></textarea>' +
									'</div>' +
									'<div class="form-group">' +
										'<label for="outputDir_' + tool.name + '">è¾“å‡ºç›®å½•:</label>' +
										'<input type="text" id="outputDir_' + tool.name + '" value="./output/" placeholder="è¯·è¾“å…¥è¾“å‡ºç›®å½•">' +
									'</div>' +
									'<button onclick="executeAudioTool(\'' + tool.name + '\')">ç”ŸæˆéŸ³é¢‘</button>' +
									'<button onclick="hideAudioForm(\'' + tool.name + '\')" style="background: #6c757d;">å–æ¶ˆ</button>' +
								'</div>';
						} else if (tool.name === 'generate_images_from_chapter_with_ai_prompt') {
							// ä¸ºå›¾åƒç”Ÿæˆå·¥å…·æ·»åŠ è¡¨å•
							buttonHtml = 
								'<h3>' + tool.name + '</h3>' +
								'<p>' + tool.description + '</p>' +
								'<button onclick="toggleImageForm(\'' + tool.name + '\')">æ‰§è¡Œå·¥å…·</button>' +
								'<div id="form_' + tool.name + '" class="audio-tool-form">' +
									'<div class="form-group">' +
										'<label for="chapterText_' + tool.name + '">ç« èŠ‚æ–‡æœ¬:</label>' +
										'<textarea id="chapterText_' + tool.name + '" placeholder="è¯·è¾“å…¥è¦ç”Ÿæˆå›¾åƒçš„ç« èŠ‚æ–‡æœ¬" rows="6"></textarea>' +
									'</div>' +
									'<div class="form-group">' +
										'<label for="outputDir_' + tool.name + '">è¾“å‡ºç›®å½•:</label>' +
										'<input type="text" id="outputDir_' + tool.name + '" value="./output/images_" placeholder="è¯·è¾“å…¥è¾“å‡ºç›®å½•">' +
									'</div>' +
									'<div class="form-group">' +
										'<label for="imageWidth_' + tool.name + '">å›¾åƒå®½åº¦:</label>' +
										'<input type="number" id="imageWidth_' + tool.name + '" value="512" min="256" max="2048">' +
									'</div>' +
									'<div class="form-group">' +
										'<label for="imageHeight_' + tool.name + '">å›¾åƒé«˜åº¦:</label>' +
										'<input type="number" id="imageHeight_' + tool.name + '" value="896" min="256" max="2048">' +
									'</div>' +
									'<button onclick="executeImageTool(\'' + tool.name + '\')">ç”Ÿæˆå›¾åƒ</button>' +
									'<button onclick="hideImageForm(\'' + tool.name + '\')" style="background: #6c757d;">å–æ¶ˆ</button>' +
								'</div>';
						} else {
							// å…¶ä»–å·¥å…·ä½¿ç”¨æ™®é€šæŒ‰é’®
							buttonHtml = 
								'<h3>' + tool.name + '</h3>' +
								'<p>' + tool.description + '</p>' +
								'<button onclick="executeTool(\'' + tool.name + '\')">æ‰§è¡Œå·¥å…·</button>';
						}
						
						toolCard.innerHTML = buttonHtml;
						toolsListDiv.appendChild(toolCard);
					});
				})
				.catch(error => {
					console.error('Error loading tools:', error);
					// æ·»åŠ é”™è¯¯æç¤º
					const toolsListDiv = document.getElementById('tools-list');
					toolsListDiv.innerHTML = '<p style="color: red;">åŠ è½½å·¥å…·åˆ—è¡¨å¤±è´¥: ' + error.message + '</p>';
				});
		}
		
		// æ˜¾ç¤ºéŸ³é¢‘ç”Ÿæˆè¡¨å•
		function toggleAudioForm(toolName) {
			const form = document.getElementById('form_' + toolName);
			if (form) {
				form.classList.toggle('active');
			}
		}
		
		// éšè—éŸ³é¢‘ç”Ÿæˆè¡¨å•
		function hideAudioForm(toolName) {
			const form = document.getElementById('form_' + toolName);
			if (form) {
				form.classList.remove('active');
			}
		}

		// æ˜¾ç¤ºå›¾åƒç”Ÿæˆè¡¨å•
		function toggleImageForm(toolName) {
			const form = document.getElementById('form_' + toolName);
			if (form) {
				form.classList.toggle('active');
			}
		}

		// éšè—å›¾åƒç”Ÿæˆè¡¨å•
		function hideImageForm(toolName) {
			const form = document.getElementById('form_' + toolName);
			if (form) {
				form.classList.remove('active');
			}
		}

		// æ‰§è¡ŒéŸ³é¢‘ç”Ÿæˆå·¥å…·
		function executeAudioTool(toolName) {
			const textInput = document.getElementById('textInput_' + toolName).value;
			const outputDir = document.getElementById('outputDir_' + toolName).value;
			
			if (!textInput || textInput.trim() === '') {
				alert('è¯·è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬');
				return;
			}
			
			// ç”Ÿæˆè¾“å‡ºæ–‡ä»¶è·¯å¾„
			const timestamp = new Date().getTime();
			const outputFile = outputDir + '/audio_' + timestamp + '.wav';
			
			const params = {
				toolName: toolName,
				text: textInput,
				output_file: outputFile
			};
			
			fetch('/api/execute', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(params)
			})
			.then(response => response.json())
			.then(data => {
				console.log('Audio tool execution initiated:', data);
				// éšè—è¡¨å•
				hideAudioForm(toolName);
			})
			.catch(error => {
				console.error('Error executing audio tool:', error);
			});
		}

		// æ‰§è¡Œå›¾åƒç”Ÿæˆå·¥å…·
		function executeImageTool(toolName) {
			const chapterText = document.getElementById('chapterText_' + toolName).value;
			const outputDir = document.getElementById('outputDir_' + toolName).value;
			const imageWidth = parseInt(document.getElementById('imageWidth_' + toolName).value);
			const imageHeight = parseInt(document.getElementById('imageHeight_' + toolName).value);
			
			if (!chapterText || chapterText.trim() === '') {
				alert('è¯·è¾“å…¥è¦ç”Ÿæˆå›¾åƒçš„ç« èŠ‚æ–‡æœ¬');
				return;
			}
			
			if (!outputDir || outputDir.trim() === '') {
				alert('è¯·è¾“å…¥è¾“å‡ºç›®å½•');
				return;
			}
			
			// ç”Ÿæˆè¾“å‡ºç›®å½•è·¯å¾„
			const timestamp = new Date().getTime();
			const outputDirectory = outputDir + timestamp;
			
			const params = {
				toolName: toolName,
				chapter_text: chapterText,
				output_dir: outputDirectory,
				width: imageWidth,
				height: imageHeight
			};
			
			fetch('/api/execute', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify(params)
			})
			.then(response => response.json())
			.then(data => {
				console.log('Image tool execution initiated:', data);
				// éšè—è¡¨å•
				hideImageForm(toolName);
			})
			.catch(error => {
				console.error('Error executing image tool:', error);
			});
		}
		
		function executeTool(toolName) {
			fetch('/api/execute', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({toolName: toolName})
			})
			.then(response => response.json())
			.then(data => {
				console.log('Tool execution initiated:', data);
			})
			.catch(error => {
				console.error('Error executing tool:', error);
			});
		}
		
		function executeAll() {
			fetch('/api/execute-all', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({})
			})
			.then(response => response.json())
			.then(data => {
				console.log('All tools execution initiated:', data);
			})
			.catch(error => {
				console.error('Error executing all tools:', error);
			});
		}
		
		function stopExecution() {
			fetch('/api/stop', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({})
			})
			.then(response => response.json())
			.then(data => {
				console.log('Execution stopped:', data);
			})
			.catch(error => {
				console.error('Error stopping execution:', error);
			});
		}
		
		function handleDragOver(e) {
			e.preventDefault();
			e.stopPropagation();
			document.getElementById('uploadArea').classList.add('drag-over');
		}
		
		function handleDrop(e) {
			e.preventDefault();
			e.stopPropagation();
			document.getElementById('uploadArea').classList.remove('drag-over');
			
			const files = e.dataTransfer.files;
			if (files.length > 0) {
				// ç®€å•æ˜¾ç¤ºä¸Šä¼ çŠ¶æ€
				document.getElementById('uploadStatus').innerText = 'å·²æ”¾ç½®æ–‡ä»¶: ' + files.length + ' ä¸ªæ–‡ä»¶';
			}
		}
		
		function processFolder() {
			fetch('/api/process-folder', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({})
			})
			.then(response => response.json())
			.then(data => {
				console.log('Folder processing initiated:', data);
			})
			.catch(error => {
				console.error('Error processing folder:', error);
			});
		}
		
		// åˆå§‹åŒ– - åŠ è½½å·¥å…·åˆ—è¡¨
		window.onload = function() {
			// åœ¨åˆå§‹çŠ¶æ€ä¸‹åŠ è½½å·¥å…·åˆ—è¡¨
			if (document.querySelector('.nav-tab.active').textContent.trim() === 'MCP å·¥å…·') {
				loadToolsList();
			}
		};
	</script>
</body>
</html>`
	c.Data(http.StatusOK, "text/html; charset=utf-8", []byte(html))
}

func wsEndpoint(c *gin.Context) {
	ws, err := upgrader.Upgrade(c.Writer, c.Request, nil)
	if err != nil {
		log.Printf("WebSocket upgrade error: %v", err)
		return
	}
	defer ws.Close()

	// æ·»åŠ å®¢æˆ·ç«¯åˆ°æ˜ å°„
	clients[ws] = true
	defer func() {
		// ç¡®ä¿åœ¨å‡½æ•°é€€å‡ºæ—¶ä»å®¢æˆ·ç«¯æ˜ å°„ä¸­åˆ é™¤è¯¥å®¢æˆ·ç«¯
		delete(clients, ws)
	}()

	for {
		var msg map[string]interface{}
		err := ws.ReadJSON(&msg)
		if err != nil {
			log.Printf("WebSocket read error: %v", err)
			// å®¢æˆ·ç«¯å·²ç»æ–­å¼€è¿æ¥ï¼Œä¸éœ€è¦é¢å¤–å¤„ç†ï¼Œdeferä¼šè‡ªåŠ¨åˆ é™¤
			break
		}
		// å¯ä»¥å¤„ç†ä»å®¢æˆ·ç«¯å‘é€çš„æ¶ˆæ¯ï¼Œå¦‚æœéœ€è¦çš„è¯
	}
}

func apiToolsHandler(c *gin.Context) {
	c.JSON(http.StatusOK, mcpTools)
}

func apiExecuteHandler(c *gin.Context) {
	var reqBody map[string]interface{} // ä¿®æ”¹ä¸ºinterface{}ä»¥æ”¯æŒä¸åŒç±»å‹å‚æ•°
	err := json.NewDecoder(c.Request.Body).Decode(&reqBody)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON"})
		return
	}

	toolName, ok := reqBody["toolName"].(string)
	if !ok || toolName == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Missing toolName"})
		return
	}

	// å¯åŠ¨MCPå·¥å…·æ‰§è¡Œ
	go func() {
		// æ£€æŸ¥å·¥å…·æ˜¯å¦å­˜åœ¨
		toolExists := false
		for _, tool := range mcpTools {
			if tool.Name == toolName {
				toolExists = true
				break
			}
		}

		if !toolExists {
			broadcast <- MCPLog{
				ToolName:  toolName,
				Message:   "å·¥å…·ä¸å­˜åœ¨: " + toolName,
				Type:      "error",
				Timestamp: time.Now().Format(time.RFC3339),
			}
			return
		}

		broadcast <- MCPLog{
			ToolName:  toolName,
			Message:   "å¼€å§‹æ‰§è¡Œå·¥å…·...",
			Type:      "info",
			Timestamp: time.Now().Format(time.RFC3339),
		}

		// å¯¹äºgenerate_indextts2_audioå·¥å…·ï¼Œå¤„ç†æ–‡æœ¬è¾“å…¥å’ŒéŸ³é¢‘ç”Ÿæˆ
		if toolName == "generate_indextts2_audio" {
			text, ok := reqBody["text"].(string)
			if !ok || text == "" {
				text = "è¿™æ˜¯ä¸€ä¸ªé»˜è®¤çš„æµ‹è¯•æ–‡æœ¬ã€‚" // é»˜è®¤æ–‡æœ¬
			}

			referenceAudio, ok := reqBody["reference_audio"].(string)
			if !ok || referenceAudio == "" {
				referenceAudio = "./assets/ref_audio/ref.m4a" // é»˜è®¤å‚è€ƒéŸ³é¢‘
			}

			outputFile, ok := reqBody["output_file"].(string)
			if !ok || outputFile == "" {
				outputFile = fmt.Sprintf("./output/audio_%d.wav", time.Now().Unix()) // é»˜è®¤è¾“å‡ºæ–‡ä»¶
			}

			// ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
			outputDir := filepath.Dir(outputFile)
			if err := os.MkdirAll(outputDir, 0755); err != nil {
				broadcast <- MCPLog{
					ToolName:  toolName,
					Message:   fmt.Sprintf("åˆ›å»ºè¾“å‡ºç›®å½•å¤±è´¥: %v", err),
					Type:      "error",
					Timestamp: time.Now().Format(time.RFC3339),
				}
				return
			}

			// æ£€æŸ¥å‚è€ƒéŸ³é¢‘æ˜¯å¦å­˜åœ¨
			if _, err := os.Stat(referenceAudio); os.IsNotExist(err) {
				// å°è¯•å…¶ä»–å¯èƒ½çš„é»˜è®¤è·¯å¾„
				possiblePaths := []string{
					"./ref.m4a",
					"./éŸ³è‰².m4a",
					"./assets/ref_audio/ref.m4a",
					"./assets/ref_audio/éŸ³è‰².m4a",
				}

				found := false
				for _, path := range possiblePaths {
					if _, err := os.Stat(path); err == nil {
						referenceAudio = path
						found = true
						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("æ‰¾åˆ°å‚è€ƒéŸ³é¢‘: %s", referenceAudio),
							Type:      "info",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						break
					}
				}

				if !found {
					broadcast <- MCPLog{
						ToolName:  toolName,
						Message:   "æ‰¾ä¸åˆ°å‚è€ƒéŸ³é¢‘æ–‡ä»¶ï¼Œè¯·ç¡®ä¿å­˜åœ¨é»˜è®¤éŸ³é¢‘æ–‡ä»¶",
						Type:      "error",
						Timestamp: time.Now().Format(time.RFC3339),
					}
					return
				}
			}

			broadcast <- MCPLog{
				ToolName:  toolName,
				Message:   fmt.Sprintf("ä½¿ç”¨å‚è€ƒéŸ³é¢‘: %s", referenceAudio),
				Type:      "info",
				Timestamp: time.Now().Format(time.RFC3339),
			}

			broadcast <- MCPLog{
				ToolName:  toolName,
				Message:   fmt.Sprintf("è¾“å…¥æ–‡æœ¬: %s", text),
				Type:      "info",
				Timestamp: time.Now().Format(time.RFC3339),
			}

			// æ£€æŸ¥MCPæœåŠ¡å™¨å®ä¾‹æ˜¯å¦å­˜åœ¨
			if mcpServerInstance != nil {
				// è·å–å¤„ç†å™¨å¹¶ç›´æ¥è°ƒç”¨å·¥å…·
				handler := mcpServerInstance.GetHandler()
				if handler != nil {
					// åˆ›å»ºMockRequestå¯¹è±¡
					mockRequest := &mcp_pkg.MockRequest{
						Params: map[string]interface{}{
							"text":            text,
							"reference_audio": referenceAudio,
							"output_file":     outputFile,
						},
					}

					// è°ƒç”¨ç‰¹å®šå·¥å…·å¤„ç†å‡½æ•°
					result, err := handler.HandleGenerateIndextts2AudioDirect(mockRequest)
					if err != nil {
						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå¤±è´¥: %v", err),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						return
					}

					// æ£€æŸ¥ç»“æœ
					if success, ok := result["success"].(bool); ok && success {
						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼Œè¾“å‡ºæ–‡ä»¶: %s", outputFile),
							Type:      "success",
							Timestamp: time.Now().Format(time.RFC3339),
						}
					} else {
						errorMsg := "æœªçŸ¥é”™è¯¯"
						if result["error"] != nil {
							if errStr, ok := result["error"].(string); ok {
								errorMsg = errStr
							}
						}
						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå¤±è´¥: %s", errorMsg),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
					}
				} else {
					broadcast <- MCPLog{
						ToolName:  toolName,
						Message:   "é”™è¯¯: MCPå¤„ç†å™¨æœªåˆå§‹åŒ–",
						Type:      "error",
						Timestamp: time.Now().Format(time.RFC3339),
					}
				}
			} else {
				// å¦‚æœæ²¡æœ‰MCPæœåŠ¡å™¨å®ä¾‹ï¼Œç»™å‡ºæç¤º
				broadcast <- MCPLog{
					ToolName:  toolName,
					Message:   "é”™è¯¯: MCPæœåŠ¡å™¨æœªå¯åŠ¨ã€‚è¯·ç¡®ä¿æœåŠ¡å·²æ­£ç¡®åˆå§‹åŒ–ã€‚",
					Type:      "error",
					Timestamp: time.Now().Format(time.RFC3339),
				}
			}
		} else {
			// å…¶ä»–å·¥å…·çš„å¤„ç† - ä¹Ÿéœ€è¦ç±»ä¼¼å¤„ç†
			if mcpServerInstance != nil {
				// è·å–å¤„ç†å™¨å¹¶ç›´æ¥è°ƒç”¨å·¥å…·
				handler := mcpServerInstance.GetHandler()
				if handler != nil {
					// æ ¹æ®å·¥å…·åç§°è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
					var result map[string]interface{}
					var err error

					// ä¸ºå…¶ä»–å·¥å…·ä¼ é€’å‚æ•°
					params, ok := reqBody["params"].(map[string]interface{})
					if !ok {
						params = make(map[string]interface{})
					}

					// è¿™é‡Œéœ€è¦æ ¹æ®å·¥å…·åç§°è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
					switch toolName {
					case "generate_subtitles_from_indextts2":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateSubtitlesFromIndextts2Direct(mockRequest)
					case "file_split_novel_into_chapters":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleFileSplitNovelIntoChaptersDirect(mockRequest)
					case "generate_image_from_text":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateImageFromTextDirect(mockRequest)
					case "generate_image_from_image":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateImageFromImageDirect(mockRequest)
					case "generate_images_from_chapter_with_ai_prompt":
						// å¤„ç†ç« èŠ‚å›¾åƒç”Ÿæˆï¼ˆä½¿ç”¨AIæç¤ºè¯ï¼‰
						chapterText, ok := reqBody["chapter_text"].(string)
						if !ok {
							chapterText = "è¿™æ˜¯ä¸€ä¸ªé»˜è®¤çš„ç« èŠ‚æ–‡æœ¬ã€‚"
						}

						outputDir, ok := reqBody["output_dir"].(string)
						if !ok {
							outputDir = fmt.Sprintf("./output/chapter_images_%d", time.Now().Unix())
						}

						widthFloat, ok := reqBody["width"].(float64)
						var width int
						if ok {
							width = int(widthFloat)
						} else {
							width = 512 // é»˜è®¤å®½åº¦
						}

						heightFloat, ok := reqBody["height"].(float64)
						var height int
						if ok {
							height = int(heightFloat)
						} else {
							height = 896 // é»˜è®¤é«˜åº¦
						}

						// ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
						if err := os.MkdirAll(outputDir, 0755); err != nil {
							broadcast <- MCPLog{
								ToolName:  toolName,
								Message:   fmt.Sprintf("åˆ›å»ºè¾“å‡ºç›®å½•å¤±è´¥: %v", err),
								Type:      "error",
								Timestamp: time.Now().Format(time.RFC3339),
							}
							return
						}

						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("å¼€å§‹å¤„ç†ç« èŠ‚æ–‡æœ¬ï¼Œè¾“å‡ºç›®å½•: %s", outputDir),
							Type:      "info",
							Timestamp: time.Now().Format(time.RFC3339),
						}

						// åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰çš„æ—¥å¿—è®°å½•å™¨ï¼Œå°†å†…éƒ¨æ—¥å¿—å¹¿æ’­åˆ°å‰ç«¯
						logger, _ := zap.NewProduction()
						defer logger.Sync()

						// ä½¿ç”¨è‡ªå®šä¹‰çš„å¹¿æ’­æ—¥å¿—é€‚é…å™¨
						encoder := zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())
						writeSyncer := zapcore.AddSync(os.Stdout) // è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºï¼ŒåŒæ—¶ä¹Ÿä¼šè¢«å¹¿æ’­
						broadcastLogger := NewBroadcastLoggerAdapter(toolName, encoder, writeSyncer)
						broadcaster := zap.New(broadcastLogger)

						// ä½¿ç”¨å¸¦å¹¿æ’­åŠŸèƒ½çš„æ—¥å¿—è®°å½•å™¨åˆ›å»ºç« èŠ‚å›¾åƒç”Ÿæˆå™¨
						generator := drawthings.NewChapterImageGenerator(broadcaster)

						// ç›´æ¥è°ƒç”¨å›¾åƒç”Ÿæˆæ–¹æ³•ï¼Œè€Œä¸æ˜¯é€šè¿‡MCPå¤„ç†å™¨
						results, err := generator.GenerateImagesFromChapter(chapterText, outputDir, width, height, true)
						if err != nil {
							broadcast <- MCPLog{
								ToolName:  toolName,
								Message:   fmt.Sprintf("ç”Ÿæˆå›¾åƒå¤±è´¥: %v", err),
								Type:      "error",
								Timestamp: time.Now().Format(time.RFC3339),
							}
							return
						}

						// å‡†å¤‡ç»“æœ
						imageFiles := make([]string, len(results))
						paragraphs := make([]string, len(results))
						prompts := make([]string, len(results))

						for i, result := range results {
							imageFiles[i] = result.ImageFile
							paragraphs[i] = result.ParagraphText
							prompts[i] = result.ImagePrompt
						}

						result = map[string]interface{}{
							"success":               true,
							"output_dir":            outputDir,
							"chapter_text_length":   len(chapterText),
							"generated_image_count": len(results),
							"image_files":           imageFiles,
							"paragraphs":            paragraphs,
							"prompts":               prompts,
							"width":                 width,
							"height":                height,
							"is_suspense":           true,
							"tool":                  "drawthings_chapter_txt2img_with_ai_prompt",
						}
					default:
						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("æš‚ä¸æ”¯æŒç›´æ¥è°ƒç”¨å·¥å…·: %s", toolName),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						return
					}

					if err != nil {
						broadcast <- MCPLog{
							ToolName:  toolName,
							Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå¤±è´¥: %v", err),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						return
					}

					// è®°å½•æ‰§è¡Œç»“æœ
					broadcast <- MCPLog{
						ToolName:  toolName,
						Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå®Œæˆï¼Œç»“æœ: %+v", result),
						Type:      "info",
						Timestamp: time.Now().Format(time.RFC3339),
					}
				} else {
					broadcast <- MCPLog{
						ToolName:  toolName,
						Message:   "é”™è¯¯: MCPå¤„ç†å™¨æœªåˆå§‹åŒ–",
						Type:      "error",
						Timestamp: time.Now().Format(time.RFC3339),
					}
				}
			} else {
				broadcast <- MCPLog{
					ToolName:  toolName,
					Message:   "é”™è¯¯: MCPæœåŠ¡å™¨æœªå¯åŠ¨ã€‚è¯·ç¡®ä¿æœåŠ¡å·²æ­£ç¡®åˆå§‹åŒ–ã€‚",
					Type:      "error",
					Timestamp: time.Now().Format(time.RFC3339),
				}
			}
		}

		broadcast <- MCPLog{
			ToolName:  toolName,
			Message:   "å·¥å…·æ‰§è¡Œå®Œæˆ",
			Type:      "success",
			Timestamp: time.Now().Format(time.RFC3339),
		}
	}()

	c.JSON(http.StatusOK, gin.H{"status": "success", "message": "Tool execution started"})
}

func apiExecuteAllHandler(c *gin.Context) {
	// æ‰§è¡Œæ‰€æœ‰MCPå·¥å…·
	go func() {
		for _, tool := range mcpTools {
			broadcast <- MCPLog{
				ToolName:  tool.Name,
				Message:   "å¼€å§‹æ‰§è¡Œå·¥å…·...",
				Type:      "info",
				Timestamp: time.Now().Format(time.RFC3339),
			}

			// æ£€æŸ¥MCPæœåŠ¡å™¨å®ä¾‹æ˜¯å¦å­˜åœ¨
			if mcpServerInstance != nil {
				// è·å–å¤„ç†å™¨å¹¶ç›´æ¥è°ƒç”¨å·¥å…·
				handler := mcpServerInstance.GetHandler()
				if handler != nil {
					// æ ¹æ®å·¥å…·åç§°è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
					var result map[string]interface{}
					var err error

					// ä¸ºå·¥å…·ä¼ é€’é»˜è®¤å‚æ•°
					params := make(map[string]interface{})

					// è¿™é‡Œéœ€è¦æ ¹æ®å·¥å…·åç§°è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
					switch tool.Name {
					case "generate_subtitles_from_indextts2":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateSubtitlesFromIndextts2Direct(mockRequest)
					case "file_split_novel_into_chapters":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleFileSplitNovelIntoChaptersDirect(mockRequest)
					case "generate_image_from_text":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateImageFromTextDirect(mockRequest)
					case "generate_image_from_image":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateImageFromImageDirect(mockRequest)
					case "generate_indextts2_audio":
						// å¯¹äºéŸ³é¢‘ç”Ÿæˆå·¥å…·ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°
						defaultParams := map[string]interface{}{
							"text":            "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•éŸ³é¢‘ã€‚",
							"reference_audio": "./assets/ref_audio/ref.m4a",
							"output_file":     fmt.Sprintf("./output/test_%d.wav", time.Now().Unix()),
						}
						mockRequest := &mcp_pkg.MockRequest{Params: defaultParams}
						result, err = handler.HandleGenerateIndextts2AudioDirect(mockRequest)
					default:
						broadcast <- MCPLog{
							ToolName:  tool.Name,
							Message:   fmt.Sprintf("æš‚ä¸æ”¯æŒç›´æ¥è°ƒç”¨å·¥å…·: %s", tool.Name),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						continue
					}

					if err != nil {
						broadcast <- MCPLog{
							ToolName:  tool.Name,
							Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå¤±è´¥: %v", err),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						continue
					}

					// è®°å½•æ‰§è¡Œç»“æœ
					broadcast <- MCPLog{
						ToolName:  tool.Name,
						Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå®Œæˆï¼Œç»“æœ: %+v", result),
						Type:      "info",
						Timestamp: time.Now().Format(time.RFC3339),
					}
				} else {
					broadcast <- MCPLog{
						ToolName:  tool.Name,
						Message:   "é”™è¯¯: MCPå¤„ç†å™¨æœªåˆå§‹åŒ–",
						Type:      "error",
						Timestamp: time.Now().Format(time.RFC3339),
					}
				}
			} else {
				// å¦‚æœæ²¡æœ‰MCPæœåŠ¡å™¨å®ä¾‹ï¼Œç»™å‡ºæç¤º
				broadcast <- MCPLog{
					ToolName:  tool.Name,
					Message:   "é”™è¯¯: MCPæœåŠ¡å™¨æœªå¯åŠ¨ã€‚è¯·ç¡®ä¿æœåŠ¡å·²æ­£ç¡®åˆå§‹åŒ–ã€‚",
					Type:      "error",
					Timestamp: time.Now().Format(time.RFC3339),
				}
			}

			broadcast <- MCPLog{
				ToolName:  tool.Name,
				Message:   tool.Name + " æ‰§è¡Œå®Œæˆ",
				Type:      "success",
				Timestamp: time.Now().Format(time.RFC3339),
			}
		}
	}()

	c.JSON(http.StatusOK, gin.H{"status": "success", "message": "All tools execution started"})
}

func apiProcessFolderHandler(c *gin.Context) {
	// å¤„ç†ä¸Šä¼ çš„æ–‡ä»¶å¤¹
	go func() {
		broadcast <- MCPLog{
			ToolName:  "å·¥ä½œæµ",
			Message:   "å¼€å§‹æ–‡ä»¶å¤¹å¤„ç†å·¥ä½œæµ...",
			Type:      "info",
			Timestamp: time.Now().Format(time.RFC3339),
		}

		// æ£€æŸ¥MCPæœåŠ¡å™¨å®ä¾‹æ˜¯å¦å­˜åœ¨
		if mcpServerInstance != nil {
			// è·å–å¤„ç†å™¨å¹¶ç›´æ¥è°ƒç”¨å·¥å…·
			handler := mcpServerInstance.GetHandler()
			if handler != nil {
				// æ¨¡æ‹Ÿå·¥ä½œæµå¤„ç†
				for _, tool := range mcpTools {
					broadcast <- MCPLog{
						ToolName:  tool.Name,
						Message:   "ä½¿ç”¨ " + tool.Name + " å¤„ç†...",
						Type:      "info",
						Timestamp: time.Now().Format(time.RFC3339),
					}

					// æ ¹æ®å·¥å…·åç§°è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
					var result map[string]interface{}
					var err error

					// ä¸ºå·¥å…·ä¼ é€’é»˜è®¤å‚æ•°
					params := make(map[string]interface{})

					// è¿™é‡Œéœ€è¦æ ¹æ®å·¥å…·åç§°è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°
					switch tool.Name {
					case "generate_subtitles_from_indextts2":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateSubtitlesFromIndextts2Direct(mockRequest)
					case "file_split_novel_into_chapters":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleFileSplitNovelIntoChaptersDirect(mockRequest)
					case "generate_image_from_text":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateImageFromTextDirect(mockRequest)
					case "generate_image_from_image":
						mockRequest := &mcp_pkg.MockRequest{Params: params}
						result, err = handler.HandleGenerateImageFromImageDirect(mockRequest)
					case "generate_indextts2_audio":
						// å¯¹äºéŸ³é¢‘ç”Ÿæˆå·¥å…·ï¼Œä½¿ç”¨é»˜è®¤å‚æ•°
						defaultParams := map[string]interface{}{
							"text":            "è¿™æ˜¯æ–‡ä»¶å¤¹å¤„ç†çš„ä¸€éƒ¨åˆ†ã€‚",
							"reference_audio": "./assets/ref_audio/ref.m4a",
							"output_file":     fmt.Sprintf("./output/folder_process_%d.wav", time.Now().Unix()),
						}
						mockRequest := &mcp_pkg.MockRequest{Params: defaultParams}
						result, err = handler.HandleGenerateIndextts2AudioDirect(mockRequest)
					default:
						broadcast <- MCPLog{
							ToolName:  tool.Name,
							Message:   fmt.Sprintf("æš‚ä¸æ”¯æŒç›´æ¥è°ƒç”¨å·¥å…·: %s", tool.Name),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
						continue
					}

					if err != nil {
						broadcast <- MCPLog{
							ToolName:  tool.Name,
							Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå¤±è´¥: %v", err),
							Type:      "error",
							Timestamp: time.Now().Format(time.RFC3339),
						}
					} else {
						// è®°å½•æ‰§è¡Œç»“æœ
						broadcast <- MCPLog{
							ToolName:  tool.Name,
							Message:   fmt.Sprintf("å·¥å…·æ‰§è¡Œå®Œæˆï¼Œç»“æœ: %+v", result),
							Type:      "info",
							Timestamp: time.Now().Format(time.RFC3339),
						}
					}

					broadcast <- MCPLog{
						ToolName:  tool.Name,
						Message:   tool.Name + " å®Œæˆ",
						Type:      "success",
						Timestamp: time.Now().Format(time.RFC3339),
					}
				}
			} else {
				broadcast <- MCPLog{
					ToolName:  "å·¥ä½œæµ",
					Message:   "é”™è¯¯: MCPå¤„ç†å™¨æœªåˆå§‹åŒ–",
					Type:      "error",
					Timestamp: time.Now().Format(time.RFC3339),
				}
			}
		} else {
			broadcast <- MCPLog{
				ToolName:  "å·¥ä½œæµ",
				Message:   "é”™è¯¯: MCPæœåŠ¡å™¨æœªå¯åŠ¨ã€‚è¯·ç¡®ä¿æœåŠ¡å·²æ­£ç¡®åˆå§‹åŒ–ã€‚",
				Type:      "error",
				Timestamp: time.Now().Format(time.RFC3339),
			}
		}

		broadcast <- MCPLog{
			ToolName:  "å·¥ä½œæµ",
			Message:   "æ–‡ä»¶å¤¹å¤„ç†å®Œæˆ",
			Type:      "success",
			Timestamp: time.Now().Format(time.RFC3339),
		}
	}()

	c.JSON(http.StatusOK, gin.H{"status": "success", "message": "Folder processing started"})
}

// fileListHandler è¿”å›æŒ‡å®šç›®å½•ä¸­çš„æ–‡ä»¶åˆ—è¡¨
func fileListHandler(c *gin.Context) {
	dir := c.Query("dir")
	if dir == "" {
		dir = "./input" // é»˜è®¤ç›®å½•
	}

	// è§£ç URLå‚æ•°
	decodedDir, err := url.QueryUnescape(dir)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid directory path", "status": "error"})
		return
	}

	// ç¡®ä¿è·¯å¾„å®‰å…¨ï¼Œé˜²æ­¢è·¯å¾„éå†æ”»å‡»
	cleanDir := filepath.Clean(decodedDir)

	// æ£€æŸ¥æ˜¯å¦ä»¥ ./input æˆ– ./output å¼€å¤´ï¼Œæˆ–è€…å°±æ˜¯ ./input æˆ– ./output
	isValidPath := strings.HasPrefix(cleanDir, "./input/") ||
		strings.HasPrefix(cleanDir, "./output/") ||
		cleanDir == "./input" ||
		cleanDir == "./output"

	if !isValidPath {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied", "status": "error"})
		return
	}

	files, err := os.ReadDir(cleanDir)
	if err != nil {
		if os.IsNotExist(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "Directory not found", "status": "error"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error(), "status": "error"})
		return
	}

	var fileList []map[string]interface{}
	for _, file := range files {
		filePath := filepath.Join(cleanDir, file.Name())
		info, err := os.Stat(filePath)
		if err != nil {
			continue
		}

		fileInfo := map[string]interface{}{
			"name":    file.Name(),
			"size":    info.Size(),
			"modTime": info.ModTime().Format(time.RFC3339),
			"isDir":   file.IsDir(),
			"type":    getFileType(file.Name()),
		}
		fileList = append(fileList, fileInfo)
	}

	c.JSON(http.StatusOK, gin.H{"files": fileList, "directory": cleanDir})
}

// fileContentHandler è¿”å›æ–‡ä»¶çš„å†…å®¹
func fileContentHandler(c *gin.Context) {
	pathParam := c.Query("path")
	if pathParam == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File path is required", "status": "error"})
		return
	}

	// è§£ç URLå‚æ•°
	decodedPath, err := url.QueryUnescape(pathParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid file path", "status": "error"})
		return
	}

	// ç¡®ä¿è·¯å¾„å®‰å…¨ï¼Œé˜²æ­¢è·¯å¾„éå†æ”»å‡»
	cleanPath := filepath.Clean(decodedPath)

	// æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„ç›®å½•èŒƒå›´å†…
	isValidPath := strings.HasPrefix(cleanPath, "./input/") ||
		strings.HasPrefix(cleanPath, "./output/") ||
		cleanPath == "./input" ||
		cleanPath == "./output"

	if !isValidPath {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied", "status": "error"})
		return
	}

	// æ£€æŸ¥æ–‡ä»¶ç±»å‹ï¼Œåªå…è®¸é¢„è§ˆç‰¹å®šç±»å‹çš„æ–‡ä»¶
	fileExt := strings.ToLower(filepath.Ext(cleanPath))
	allowedExts := map[string]bool{
		".txt":  true,
		".md":   true,
		".json": true,
		".yaml": true,
		".yml":  true,
		".xml":  true,
		".csv":  true,
		".log":  true,
	}

	if !allowedExts[fileExt] {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File type not supported for preview", "status": "error"})
		return
	}

	content, err := os.ReadFile(cleanPath)
	if err != nil {
		if os.IsNotExist(err) {
			c.JSON(http.StatusNotFound, gin.H{"error": "File not found", "status": "error"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error(), "status": "error"})
		return
	}

	c.Data(http.StatusOK, "text/plain; charset=utf-8", content)
}

// fileDeleteHandler åˆ é™¤æŒ‡å®šçš„æ–‡ä»¶æˆ–ç›®å½•
func fileDeleteHandler(c *gin.Context) {
	pathParam := c.Query("path")
	if pathParam == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "File path is required", "status": "error"})
		return
	}

	// è§£ç URLå‚æ•°
	decodedPath, err := url.QueryUnescape(pathParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid file path", "status": "error"})
		return
	}

	// ç¡®ä¿è·¯å¾„å®‰å…¨ï¼Œé˜²æ­¢è·¯å¾„éå†æ”»å‡»
	cleanPath := filepath.Clean(decodedPath)

	// æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„ç›®å½•èŒƒå›´å†…
	isValidPath := strings.HasPrefix(cleanPath, "./input/") ||
		strings.HasPrefix(cleanPath, "./output/") ||
		cleanPath == "./input" ||
		cleanPath == "./output"

	if !isValidPath {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied", "status": "error"})
		return
	}

	// ç¡®è®¤æ–‡ä»¶æˆ–ç›®å½•å­˜åœ¨
	if _, err := os.Stat(cleanPath); os.IsNotExist(err) {
		c.JSON(http.StatusNotFound, gin.H{"error": "File or directory does not exist", "status": "error"})
		return
	}

	err = os.RemoveAll(cleanPath) // ä½¿ç”¨RemoveAllå¯ä»¥åˆ é™¤éç©ºç›®å½•
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete file or directory: " + err.Error(), "status": "error"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "success", "message": "File or directory deleted successfully"})
}

// fileUploadHandler ä¸Šä¼ æ–‡ä»¶åˆ°æŒ‡å®šç›®å½•
func fileUploadHandler(c *gin.Context) {
	// è§£æ multipart form (32MB max)
	err := c.Request.ParseMultipartForm(32 << 20) // 32MB max memory
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Unable to parse form", "status": "error"})
		return
	}

	dir := c.PostForm("dir")
	if dir == "" {
		dir = "./input" // é»˜è®¤ç›®å½•
	}

	// ç¡®ä¿è·¯å¾„å®‰å…¨ï¼Œé˜²æ­¢è·¯å¾„éå†æ”»å‡»
	if !strings.HasPrefix(filepath.Clean(dir), "./input") && !strings.HasPrefix(filepath.Clean(dir), "./output") {
		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied", "status": "error"})
		return
	}

	// ç¡®ä¿ç›®å½•å­˜åœ¨
	if err := os.MkdirAll(dir, 0755); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Unable to create directory", "status": "error"})
		return
	}

	file, handler, err := c.Request.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Error retrieving file", "status": "error"})
		return
	}
	defer file.Close()

	filePath := filepath.Join(dir, handler.Filename)
	dest, err := os.Create(filePath)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error creating file", "status": "error"})
		return
	}
	defer dest.Close()

	_, err = io.Copy(dest, file)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error saving file", "status": "error"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"status": "success", "filename": handler.Filename, "message": "File uploaded successfully"})
}

// getFileType æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®šæ–‡ä»¶ç±»å‹
func getFileType(filename string) string {
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".svg", ".webp":
		return "image"
	case ".mp4", ".avi", ".mov", ".wmv", ".flv", ".mkv":
		return "video"
	case ".mp3", ".wav", ".flac", ".aac", ".ogg":
		return "audio"
	case ".txt", ".md", ".json", ".yaml", ".yml", ".xml", ".csv", ".log":
		return "text"
	case ".pdf":
		return "pdf"
	case ".zip", ".rar", ".tar", ".gz", ".7z":
		return "archive"
	default:
		return "unknown"
	}
}

// BroadcastLoggerAdapter æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰çš„zapcore.Coreå®ç°ï¼Œç”¨äºå°†æ—¥å¿—å¹¿æ’­åˆ°WebSocket
type BroadcastLoggerAdapter struct {
	toolName string
	zapcore.Core
}

// NewBroadcastLoggerAdapter åˆ›å»ºä¸€ä¸ªæ–°çš„å¹¿æ’­æ—¥å¿—é€‚é…å™¨
func NewBroadcastLoggerAdapter(toolName string, encoder zapcore.Encoder, writeSyncer zapcore.WriteSyncer) *BroadcastLoggerAdapter {
	core := zapcore.NewCore(encoder, writeSyncer, zapcore.DebugLevel)
	return &BroadcastLoggerAdapter{
		toolName: toolName,
		Core:     core,
	}
}

// With æ·»åŠ å­—æ®µå¹¶è¿”å›æ–°çš„Core
func (b *BroadcastLoggerAdapter) With(fields []zapcore.Field) zapcore.Core {
	newCore := b.Core.With(fields)
	return &BroadcastLoggerAdapter{
		toolName: b.toolName,
		Core:     newCore,
	}
}

// Check æ£€æŸ¥æ—¥å¿—çº§åˆ«æ˜¯å¦å¯ç”¨
func (b *BroadcastLoggerAdapter) Check(entry zapcore.Entry, ce *zapcore.CheckedEntry) *zapcore.CheckedEntry {
	if b.Core.Enabled(entry.Level) {
		return ce.AddCore(entry, b)
	}
	return ce
}

// Write å°†æ—¥å¿—æ¡ç›®å†™å…¥å¹¶å¹¿æ’­åˆ°WebSocket
func (b *BroadcastLoggerAdapter) Write(entry zapcore.Entry, fields []zapcore.Field) error {
	// é¦–å…ˆè®©åº•å±‚coreå¤„ç†æ—¥å¿—
	err := b.Core.Write(entry, fields)

	// æ„å»ºæ—¥å¿—æ¶ˆæ¯
	// åˆ›å»ºä¸€ä¸ªä¸´æ—¶ç¼–ç å™¨æ¥ç”Ÿæˆæ—¥å¿—æ¶ˆæ¯
	encoder := zapcore.NewConsoleEncoder(zap.NewDevelopmentEncoderConfig())
	buffer, err2 := encoder.EncodeEntry(entry, fields)
	if err2 != nil {
		// å¦‚æœç¼–ç å¤±è´¥ï¼Œä½¿ç”¨ç®€å•æ¶ˆæ¯
		broadcast <- MCPLog{
			ToolName:  b.toolName,
			Message:   fmt.Sprintf("æ—¥å¿—ç¼–ç å¤±è´¥: %v", err2),
			Type:      "error",
			Timestamp: entry.Time.Format(time.RFC3339),
		}
		return err
	}

	message := strings.TrimSpace(string(buffer.Bytes()))

	// å¹¿æ’­åˆ°WebSocket
	logType := "info"
	switch entry.Level {
	case zapcore.ErrorLevel:
		logType = "error"
	case zapcore.WarnLevel:
		logType = "error" // ä½¿ç”¨errorç±»å‹æ˜¾ç¤ºè­¦å‘Š
	case zapcore.DPanicLevel, zapcore.PanicLevel, zapcore.FatalLevel:
		logType = "error"
	}

	broadcast <- MCPLog{
		ToolName:  b.toolName,
		Message:   message,
		Type:      logType,
		Timestamp: entry.Time.Format(time.RFC3339),
	}

	return err
}

func main() {
	loadToolsList()

	go handleLogs()

	// è®¾ç½®Ginä¸ºå‘å¸ƒæ¨¡å¼ä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½
	gin.SetMode(gin.ReleaseMode)
	r := gin.Default()

	// æ³¨å†Œè·¯ç”±
	r.GET("/", homePage)
	r.GET("/ws", wsEndpoint)
	r.GET("/api/tools", apiToolsHandler)
	r.POST("/api/execute", apiExecuteHandler)
	r.POST("/api/execute-all", apiExecuteAllHandler)
	r.POST("/api/process-folder", apiProcessFolderHandler)
	// æ·»åŠ æ–‡ä»¶ç®¡ç†APIç«¯ç‚¹
	r.GET("/api/files/list", fileListHandler)
	r.GET("/api/files/content", fileContentHandler)
	r.DELETE("/api/files/delete", fileDeleteHandler)
	r.POST("/api/files/upload", fileUploadHandler)

	// ä»ç¯å¢ƒå˜é‡è·å–ç«¯å£ï¼Œé»˜è®¤ä¸º8080
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ :" + port)
	r.Run(":" + port)
}
